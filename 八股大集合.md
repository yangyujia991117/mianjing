# 面试八股大集合

## java概念

### 1、接口和抽象类的共同点和区别

**共同点** ：

- 都<font color=red>不能被实例化</font>。
- 都可以包含<font color=red>抽象方法</font>。（所谓的抽象方法就是没有默认实现的方法，抽象方法不能用private、final、static、native修饰，否则子类无法重写）
- 都可以有<font color=red>默认实现的方法</font>（Java 8 可以用 `default` 关键字在接口中定义默认方法）。
- 抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么<font color="red">该子类只能是抽象类</font>。同样，一个类实现接口的时候，如不能全部实现接口方法，那么<font color="red">该子类也只能为抽象类</font>。

**区别** ：

- 接口主要用于对<font color=red>类的行为</font>进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是<font color=red>所属关系</font>。
- <font color=red>一个类只能继承一个类，但是可以实现多个接口</font>。
- 接口中的成员变量只能是 <font color=red>`public static final`</font> 类型的，<font color="red">不能被修改且必须有初始值</font>，而抽象类的成员变量默认<font color=red> default</font>，可在子类中被重新定义，也可被重新赋值。

### 2、一个接口是否可以实现另一个接口，如果B接口实现了A接口的话，它能不能实现A接口的方法

接口<font color="red">不能实现接口，只能继承一个或多个接口</font>，因为接口不能实现另一个接口中的抽象方法。

抽象类可以实现接口，对应的实现方法体可以为空，在抽象类的具体实现类中再写方法的具体实现

### 3、java中8种基本数据类型的大小、默认值

| 基本类型               | 位数                        | 字节 | 默认值  | 取值范围                                   |
| :--------------------- | :-------------------------- | :--- | :------ | ------------------------------------------ |
| `byte`                 | 8                           | 1    | 0       | -128 ~ 127                                 |
| `short`                | <font color="red">16</font> | 2    | 0       | -32768 ~ 32767                             |
| `int`                  | <font color="red">32</font> | 4    | 0       | -2147483648 ~ 2147483647                   |
| `long`                 | 64                          | 8    | 0L      | -9223372036854775808 ~ 9223372036854775807 |
| `char`                 | <font color="red">16</font> | 2    | 'u0000' | 0 ~ 65535                                  |
| `float`(32位浮点数)    | 32                          | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                     |
| `double`（64位浮点数） | 64                          | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308          |
| `boolean`              | 1                           |      | false   | true、false                                |

### 4.反射的机制了解吗，用途？

用途：通过反射可以实现<font color="Red">在运行时分析类以及执行类中方法</font>，在运行时通过反射可以获取任意一个类的所有属性和方法，还可以调用它的方法和属性

机制：

- 获取类

  ```java
  //方法一：直接获取已知类
  Class alunbarClass = TargetObject.class;
  
  //方法二：通过Class.forName完整类路径（含包路径）获取类
  Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");
  
  //方法三：通过这个类的对象.getClass获取
  TargetObject o = new TargetObject();
  Class alunbarClass2 = o.getClass();
  
  //方法四：通过类加载器的loadClass方法传入类路径获取
  //这里getSystemClassLoader()得到的是AppClassLoader
  Class<?> aclass=ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.TargetObject");
  
  ```

- 操作类中的属性及方法

  - getDeclaredMethod、getDeclaredMethods：可以获得定义的所有方法，包括非protect的，但不包括继承而来的，但是invoke非public方法之前需要根据当前反射调用的位置和对应方法的相对关系来判断是否要先setAccessible(true)，例如反射调用位置和被反射的类不在一个包下时，invoke protected方法前就要先setAccessible(true)
  - getMethod、getMethods：可以获得所有public方法，以及所有继承而来的方法
  
  ```java
  		/**
           * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例
           */
          Class<?> targetClass = Class.forName("cn.javaguide.TargetObject");
          TargetObject targetObject = (TargetObject) targetClass.newInstance();
          /**
           * 通过getDeclaredMethods获取 TargetObject 类中定义的所有方法（包括private的）
           */
          Method[] methods = targetClass.getDeclaredMethods();
          for (Method method : methods) {
              System.out.println(method.getName());
          }
  
  		/**
  		* 通过getMethod获得某个公共方法(或继承而来的方法)
  		*/
  		Method publicMethod=getMethod("method1")
  
          /**
           * 通过getDeclaredMethods传入方法名获取指定方法，并传入对应参数进行调用（可以获得private方法，但是调用需要先setAccessible(true)
           */
          Method method = targetClass.getDeclaredMethod("method1",
                  String.class);
  
          method.invoke(targetObject, "JavaGuide");
  
          /**
           * 获取指定参数并对参数进行修改
           */
          Field field = targetClass.getDeclaredField("value");
          //为了对类中的参数进行修改我们取消安全检查
          field.setAccessible(true);
          field.set(targetObject, "JavaGuide");
  
  		/**
           * 调用 private 方法
           */
          Method privateMethod = targetClass.getDeclaredMethod("privateMethod");
          //为了调用private方法我们取消安全检查
          privateMethod.setAccessible(true);
          privateMethod.invoke(targetObject);
  ```
  


### 5.==、equals()、hashcode()的联系和区别

- ==

  - 对于基本数据类型，比较值
  - 对于引用数据类型，比较的是对象的内存地址
  - <font color="red">==为true的话，两个对象一定是同一个对象（地址一样）</font>

- equals()

  - Object类的实例方法，不能用于比较基本数据类型的变量（基本数据类型变量也调不了），只能用于对象之间的比较

  - 若没有重写：实际上就是用==比较

  - 若重写了：重写之后的比较方法，例如String就是比较字符串内容

    注意重写了equals()也要重写hashcode()

- hashcode()

  - Object类的native方法，用C/C++写成

  - 在hashcode()的计算源码中，一共有6种计算hashcode的方法，通过设置`-XX:hashCode`选择用哪种方法，`-XX:hashCode`默认是5，取第六种方法，通过<font color="red">和当前线程有关的一个随机数+三个确定值</font>，用<font color="red">xor-shift（异或shift）算法</font>计算出一个<font color="red">伪随机数</font>

    ```
    -XX:hashCode=0：返回随机数
    -XX:hashCode=1：用对象的内存地址根据某种算法进行计算
    -XX:hashCode=2：始终返回1
    -XX:hashCode=3：从0开始逐个递增计算哈希值
    -XX:hashCode=4：返回对象的内存地址
    -XX:hashCode=5（默认）：利用xor-shift算法产生伪随机数
    ```

  - 用途：广泛用于一些散列表如HashMap、HashSet

    - HashSet：<font color="red">判断某个元素是否在set中，会先逐个和set里的元素比较hashcode，hashcode相同再比较equals，如果hashcode不同的话就直接不用比了，但是按理说equals等那么这时候肯定要判定这个元素在set里</font>，所以是不合理的，所以要重写hashcode
    - HashMap：通过hashcode()^(hashcode()>>>16)计算hash，从而计算索引下标

### 6.try-catch-finally

- try：用于捕获异常，后面可以<font color="red">跟0-多个catch块，如果没有catch的话后面必须有finally</font>
- catch：用于处理try中捕获到的异常，如throw一些Exception
- finally：<font color="Red">无论是否捕获或处理异常，finally中的语句都会被执行，而且是最后跟在try和catch后面执行</font>

​	注意：

1. 如果finally里面有return语句，那么它会改变try和catch中的return，<font color="red">把返回值都变为finally里面的返回值</font>，所以建议不要在finally里面写return语句
2. <font color="red">finally也不一定会执行</font>，如果在之前的try或catch里终止了虚拟机（`System.exit(1);`）、程序所在线程死亡、关闭CPU的话就不会执行，否则一定会执行

### 7.try-with-resources

当一些资源如InputStream、OutputStream、Scanner在使用完后最好close()，一般是在try-catch-finally的finally语句中一个个地关闭资源，<font color="red">如果用try-with-resources的话，就能保证return或抛出异常之前声明的所有资源一定会被关闭，不需要再手动调用close()。</font>

在try后面的()里写上所有使用的资源，用;分隔即可：

```java
try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File("test.txt")));
     BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File("out.txt")))) {
    int b;
    while ((b = bin.read()) != -1) {
        bout.write(b);
    }
}
catch (IOException e) {
    e.printStackTrace();
}

```

### 8.String、StringBuffer、StringBuilder

区别：

- String是不可变的（也是线程安全的，不可变类都是线程安全的）

  - 内部用一个<font color="red">private final</font>的char[]存所有字符，且String类里没有提供对这个char[]进行修改的方法（虽然final修饰的引用变量只是不能指向别的对象，可以修改这个对象内部的值，但String根本没有提供任何修改数组内部值的方法）
  - String类被<font color="red">final</font>修饰，导致<font color="red">不能被继承</font>，避免子类破坏它的不可变性

  ![image-20230818221822498](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230818221822498.png)

- StringBuilder、StringBuffer都继承自抽象类AbstractStringBuilder，虽然也是用一个char[]存所有字符，但这个char[]不是final的，且在append方法中，<font color="red">如果char[]容量不够，会新生成一个更大的char[]，然后把原字符串复制过去，再在新数组后面放新字符串</font>。append代码如下：

  ![image-20230818222858836](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230818222858836.png)

  每次对AbstractStringBuilder进行改变的时候返回的都是这个对象，不会返回新的AbstractStringBuilder对象

- <font color="red">StringBuffer对方法加了同步锁，线程安全；StringBuilder没有加同步锁，线程不安全，性能更快一些</font>

有关字符串拼接：

- String用+拼接时，低层字节码对应的逻辑是创建StringBuilder，然后调用StringBuilder.append，进行拼接，再调用StringBuilder.toString返回一个新的String对象，而且是调用多少句拼接就生成多少个新的StringBuilder和String对象（比如`String s="a"+"b"+"c";`这样一句就是生成了一个StringBuilder），导致占用过多内存资源
- StringBuilder和StringBuffer的字符串拼接不存在这个问题
- JDK9之后String的+改为用动态方法 `makeConcatWithConstants()` 了，不会创建大量StringBuilder了

### 9.有关String的+、=、字符串常量池

- 字符串常量池的底层实现类似一个固定大小的HashTable，key为字符串字面值，value为堆中字符串对象的引用
- `String s="aa";`  会先看字符串常量池中是否有“aa"的引用，如果有的话<font color="red">直接返回那个引用</font>，否则在堆中新建一个字符串对象然后再在字符串常量池添加它的引用，<font color="red">再返回这个常量池中的引用</font>
- `String s=new String("aa");` 会先看常量池中是否有"aa"的引用，如果没有就会在字符串创建“aa"的引用，然后在字符串常量池保存aa，如果常量池中已经有"aa"的话就直接用这个常量池的引用<font color="red">，然后一定会在堆中新建一个对象s，然后用"aa"初始化这个对象s，最后返回的是堆中这个对象s（注意不是常量池中的"aa"引用）</font>，所以可能创建了1个或2个字符串对象
- 常量折叠：在编译阶段把常量表达式的值求出来作为常量嵌在最终生成的代码中，如对于 `String s = "a" + "b";` 编译器优化为 `String s = "ab";`

有关字符串拼接：

- String用+拼接时，低层字节码对应的逻辑是<font color="red">创建StringBuilder，然后调用StringBuilder.append，进行拼接，再调用StringBuilder.toString返回一个新的String对象</font>，而且是调用多少句拼接就生成多少个新的StringBuilder和String对象（比如`String s="a"+"b"+"c";`这样一句就是生成了一个StringBuilder），导致占用过多内存资源
- StringBuilder和StringBuffer的字符串拼接不存在这个问题
- JDK9之后String的+改为用动态方法 `makeConcatWithConstants()` 了，不会创建大量StringBuilder了

### 10.transient关键字

作用：被transient关键字修饰的成员变量<font color="red">不能被序列化为字节流</font>

当一个对象实现了**Serilizable接口**，那这个对象就可以被序列化为二进制字节流，然后保存在磁盘文件或者通过网络传输，然后可以通过读取出文件内容等方式再次获得这个字节流，然后通过反序列化重新得到一个对象。<font color="red">如果这个对象里的某个成员变量被transient修饰，那么这个变量不参与这个对象的序列化，反序列化后，如果这个被transient修饰的成员变量是基本数据类型，那它就是基本数据类型的默认值，如果是引用类型的话，反序列化的结果就是null</font>

注意：static静态变量不参与序列化/反序列化，它的值一直就是程序员设置给它的那个初始值

### 11.Object类中有哪些方法

共有11个方法：

1. 类相关

   - ```java
     //用于返回该对象的Class对象，不允许子类重写
     public final native Class<?> getClass()
     ```

2. 判断相等相关

   - ```java
     public native int hashCode()
     ```

   - ```java
     public boolean equals(Object obj)
     ```

3. 克隆相关

   - ```java
     //默认都是浅拷贝，如果需要实现深拷贝那要implement Clonable然后重写这个方法
     protected native Object clone() throws CloneNotSupportedException
     ```

4. 转字符串相关

   - ```java
     //默认返回“类名+@+hashcode的十六进制字符串"
     public String toString(){
         return getClass().getName() + "@" + Integer.toHexString(hashCode());
     }
     ```

5. 多线程相关

   - ```java
     /**
      * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
      */
     public final native void notify()
     /**
      * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
      */
     public final native void notifyAll()
     /**
      * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
      */
     public final native void wait(long timeout) throws InterruptedException
     /**
      * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。
      */
     public final void wait(long timeout, int nanos) throws InterruptedException
     /**
      * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
      */
     public final void wait() throws InterruptedException
     ```

6. 垃圾回收相关

   - ```java
     /**
      * 实例被垃圾回收器回收的时候触发的操作，在可达性分析算法中假如看到某个对象的类重写了finalize方法并且finalize方法没有被调用过，那么就会将这个对象加入一个队列中，如果下次看到还是不可达那么这个对象就会真的被回收
      */
     protected void finalize() throws Throwable { }
     ```

### 12.强引用、软引用、弱引用、虚引用

在<font color="orange">判断对象死亡的两种主要方法</font>中都使用了“引用”这一概念。

- **强引用**：<font color="red">强引用指向的对象只要和这个强引用还有关联，就绝对不会被回收</font>，JVM宁可抛出outOfMemoryError使程序异常终止也不回收它。<font color="voilet">我们使用的大部分引用都是强引用，如new对象、声明常量。</font>

  例子：

  ```java
  Object obj = new Object();
  String str = "StrongReference";
  //这两个都是强引用，也就是object和str都不会被回收
  ```

  取消强引用的方法：把被引用对象设为null，如上面的obj=null，str=null

  注意：Object obj = new Object()这句，一般来说obj这个引用在虚拟机栈中，所引用的对象在堆中，当栈帧弹出后，obj这个引用没了，那么之前所引用的对象自然后面也会被回收了，因为它已经不被强引用所关联了。

- **软引用**：<font color="red">JVM GC时，只有内存空间不够时才回收</font>。可以和<font color="orange">引用队列</font>联合使用，<u>如果软引用所引用的对象被回收，JVM会将这个软引用加入到与之关联的引用队列中。</u><font color="voilet"> 可用来实现内存敏感的高速缓存，如网页缓存、图片缓存。</font>软引用对应的类是<font color="red"> java.lang.ref.SoftReference类</font>。

  例子：

  ```java
  import java.lang.ref.SoftReference;//软引用必须是这个类的
   
  public class SoftRef {  
   
      public static void main(String[] args){  
          Obj obj = new Obj();//这里是强引用          
          SoftReference<Obj> sr = new SoftReference<Obj>(obj); //创建软引用对象，软引用是sr，引用的对象是obj
          obj = null;  //删除强引用，使得该对象的回收不受强引用影响
          System.gc;//调用gc
          System.out.println(sr.get());  //可以打印出被引用的对象，说明软引用起了作用（使得被引用对象的引用计数＞0）
      }       
  }  
   
  class Obj{  
      int[] obj ;  
      public Obj(){  
          obj = new int[1000];  
      }  
  }
  ```

- **弱引用**：<font color="red">不管内存足够与否都回收</font>。也可以<font color="orange">联合引用队列</font>使用。弱引用必须是<font color="red"> java.lang.ref.WeakReference类</font> 的。  如果一个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那就可以用弱引用。<font color="voilet">也可以做缓存，且该缓存生命周期比软引用的短</font>

  例子：

  ```java
  import java.lang.ref.WeakReference;
   
  public class WeakRef {
      public static void main(String[] args) {
          WeakReference<String> sr = new WeakReference<String>(new String("hello"));//创建弱引用对象
          System.out.println(sr.get());//可以打印出被引用的对象
          System.gc();                //通知JVM的gc进行垃圾回收
          System.out.println(sr.get());//打印出null，说明没有被引用的对象了，被引用的对象已经被回收了，说明弱引用的存在并不能阻止被引用的对象被回收
      }
  }
  ```

  

- **虚引用**： <font color="red">形同虚设，并不影响对象的生命周期，在任何时候都可能被垃圾回收器回收。</font>在java中用 <font color="red">java.lang.ref.PhantomReference</font>类表示。 <font color="orange">如果一个对象与虚引用关联，则跟没有引用与之关联一样</font>。虚引用主要用来<font color="voilet">跟踪对象被垃圾回收的活动。</font> 

  <font color="orange">虚引用必须和引用队列关联使用</font>，<u>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。</u>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

  ```java
  import java.lang.ref.PhantomReference;
  import java.lang.ref.ReferenceQueue;
   
   
  public class PhantomRef {
      public static void main(String[] args) {
          ReferenceQueue<String> queue = new ReferenceQueue<String>();//引用队列
          PhantomReference<String> pr = new PhantomReference<String>(new String("hello"), queue);//创建虚引用对象
          System.out.println(pr.get());//永远打印出null，因为本来虚引用就是形同虚设！
      }
  }
  ```


### 13.java内部类（嵌套类）

语法糖的一种

出现的场景：一些数据结构中，例如HashMap里面就定义了Node这个内部类

内部类可以是静态的也可以是非静态的，并且前面可以加访问修饰符

**非静态内部类**

- 必须要创建外部类的对象，然后<font color="red">通过这个外部类的对象来new内部类的对象</font>
- 内部类可以任意访问外部类的<font color="red">所有</font>成员变量及方法（包括private），并且是直接用成员名就能访问，如果内部类有和外部类名称相同的成员变量或方法的话，那访问外部类的成员要用"<font color="red">外部类名.this.xxx</font>"，否则默认访问的是内部类自己的。（<font color="red">但是反过来，外部类不能够访问内部类的private成员</font>）

**静态内部类**

- 不需要创建外部类的对象，直接就能创建内部类的对象
- 只能访问外部类的<font color="red">static成员</font>

**private内部类**

- 只有包着它的外部类才能创建private内部类的对象，别的类创建不了

```java
package 内部类;

public class OuterClass {
    private String name;
    public OuterClass(){
        name="OuterClass";
    }
    private void sayHello(){
        System.out.println("hello");
    }
    //这个外部类可以创建private内部类的对象，但是别的类就不能创建了
    public void innerClass3GetName(){
        InnerClass3 innerClass3=new InnerClass3();
        innerClass3.getSelfName();
    }
   

    /**
     * 非静态内部类
     */
    public class InnerClass1{
        private String name;
        public InnerClass1(){
            name="InnerClass1";
        }
        public void getOuterClassName(){
            //外部类和内部类的成员变量重名，要用"外部类.this.name"才能得到外部类的name
            System.out.println(OuterClass.this.name);
        }
        public void getSelfName(){
            //前面不加"外部类.this"的话，默认就是取自己的
            System.out.println(name);
        }
        public void sayHello(){
            OuterClass.this.sayHello();
        }
    }

    /**
     * 静态内部类
     */
    public static class InnerClass2{
        private String name;
        public InnerClass2(){
            name="InnerClass2";
        }
        public void getSelfName(){
            System.out.println(name);
        }
    }
    
    /**
     * 私有内部类
     */
    private class InnerClass3{
        private String name;
        public InnerClass3(){name="InnerClass3";}
        public void getSelfName(){
            System.out.println(name);
        }
    }
}

```

```java
package 内部类;

public class Test {
    public static void main(String[] args) {
        OuterClass outerClass=new OuterClass();

        //要通过外部类的对象创建非静态内部类
        OuterClass.InnerClass1 innerClass1=outerClass.new InnerClass1();
        innerClass1.getSelfName();//输出InnerClass1
        innerClass1.getOuterClassName();//输出OuterClass
        innerClass1.sayHello();//输出hello

        //可以不通过外部类的对象直接创建静态内部类
        OuterClass.InnerClass2 innerClass2=new OuterClass.InnerClass2();
        innerClass2.getSelfName();//输出InnerClass2
        
        //不能够创建private内部类的对象，要直接包着它的那个外部类才能创建
    }
}

```

### 15. IO和NIO的区别，NIO优点

**区别：**

| IO       | NIO（IO多路复用模型） |
| -------- | --------------------- |
| 面向流   | 面向缓冲              |
| 阻塞     | 非阻塞                |
| 无选择器 | 有选择器              |

- IO/BIO  阻塞式IO
  - 面向流：每次从流中读一个或多个字节，直到读取所有字节
  - 阻塞：<font color="red">当没有数据可读的时候，线程一直阻塞被占用，直到数据到来</font>。
- NIO  非阻塞式IO
  - 面向通道和缓冲区：数据总是从通道（每个io连接就是一个通道）读取到缓冲区中，或者从缓冲区写入到通道中，需要时可在缓冲区中前后移动
  - 非阻塞：从某个通道读取数据时，会根据返回值判断缓冲区里是否读进了这个通道的数据，如果没有数据就不会阻塞，可以先做别的事情，过一段时间再回来看是否有数据。
  - 有选择器：线程可以通过<font color="red">选择器</font>，进行多个通道的选择，选择合适的通道进行读取/写入

### 16.单例模式的几种写法

注意这几种写法中类的<font color="red">构造函数一定要弄成private的，避免通过构造函数直接构建对象</font>

#### 饿汉式（可以用，线程安全）

- 在<font color="red">类加载的初始化阶段</font>，singleton就会指向一个初始化好的对象

- 可能singleton后面并不需要使用，这样做浪费了空间

- <font color="red">线程安全</font>（类加载机制中final static成员只能初始化一次）

  ```java
  public class Singleton{
      
      private final static Singleton singleton=new Singleton();
      
      //注意构造函数要设为私有的
      private Singleton(){}
      
      public static Singleton getInstance(){
          return singleton;
      }
  }
  ```

#### 最原始的懒汉式（不要用，线程不安全）

- 判断singleton为null才创建对象，懒加载，避免了空间浪费

- <font color="red">线程不安全</font>：多线程环境下，可能两个线程这时候都判断singleton为null，然后其中一个线程new了Singleton，这时候另一个线程并不知道，也new了Singleton，这时候singleton就前后指向了两个对象，不符合单例了

  ```java
  public class Singleton{
      
      private static Singleton singleton;
      
      //注意构造函数要设为私有的
      private Singleton(){}
      
      public static Singleton getInstance(){
          if (singleton == null) {
              singleton = new Singleton();
          }
          return singleton;
      }
  }
  ```

#### 整个方法加synchronized的懒汉式（不要用，效率低）

- 只要调用getInstance方法就要获取锁，<font color="red">线程安全但效率低</font>

  ```java
  public synchronized static Singleton getInstance(){
          if (singleton == null) {
              singleton = new Singleton();
          }
          return singleton;
      }
  ```

#### synchronized代码块的懒汉式（不要用，线程不安全）

- 不是给整个方法加锁，而是判断为null后创建对象之前进入一个synchronized代码块

- <font color="red">线程不安全</font>：当一个线程创建了对象之后，这时候别的线程可能在之前也进入了synchronized代码块，但不知道这个对象已经创建了，这时候也会创建新的对象，也就有多个对象了

  ```java
  public static Singleton getInstance(){
          if (singleton == null) {
              synchronized(Singleton.class){
              	singleton = new Singleton();
              }
          }
          return singleton;
      }
  ```

#### 双重检测锁的懒汉式（可以用，线程安全）

- <font color="red">线程安全：</font>在synchronized代码块里也进行一次是否为null的判断，如果是的话才创建对象，避免出现上一种方法的问题

- <font color="red">注意：要想完整保证线程安全，singleton要用volatile修饰，</font>以保证`singleton = new Singleton();`这句话的有序性，因为这句话并不是原子操作，分为1.分配内存、2.在内存初始化、3.使对象指向内存地址这三步，可能会出现指令重排，例如重排为了1、3、2的话，如果线程A执行完了1、3但还没执行2，也就是现在不为null但是指向一个未初始化的内存，这时候线程B看到不为null了就直接把这个未初始化内存空间的singleton对象返回了，这时候就会出问题

  完整代码如下：

  ```java
  public class Singleton{
      private volatile static Singleton singleton;
      
      //注意构造函数要设为私有的
      private Singleton(){}
      
      public static Singleton getInstance(){
          if (singleton == null) {
              synchronized(Singleton.class){
                  if(singleton==null){
              		singleton = new Singleton();
                  }
              }
          }
          return singleton;
      }
  }
  ```

#### 静态内部类（可以用，线程安全）

- 因为静态内部类只有直接包着它的这个外部类才可以访问，所以也是当调用getInstance的时候才会加载创建singleton对象（才触发了静态内部类的初始化阶段），且因为是利用类加载机制，所以也能保证线程安全

  ```java
  public class Singleton {
      private Singleton(){}
  
      /**
      静态内部类
      **/
      private static class SingletonHolder{
          private static final Singleton singleton=new Singleton();
      }
  
      public static final Singleton getInstance(){
          return SingletonHolder.singleton;
      }
  }
  ```

#### 枚举类（可以用，线程安全）

上面几种方法都可以通过反射，破坏其构造函数的私有性：

![image-20231006133233175](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231006133233175.png)

上面代码执行的结果是false，原因是虽然构造函数被弄成了private，但是还是可以通过反射机制的setAccessible(true)执行private方法构建这个类的对象，也就是前面要实现的一个目的——只通过getInstance得到单例对象就没有达到。

<font color="red">运用枚举类型，能够避免反射的破坏，因为通过反射不能创建枚举类型的对象</font>

java枚举的机制会自动创建一个用<font color="red">final</font>修饰的继承Enum类的子类Singleton类，然后创建Singleton的一个成员——<font color="red">static final</font>的Singleton对象SINGLETON，后续使用<font color="pink">Singleton.SINGLETON</font>就可以使用这个对象了，因为是<font color="red">利用类加载机制实现的单例，所以也线程安全</font>

```java
public enum Singleton {
    SINGLETON;
}
```

### 17.java注解

https://www.cnblogs.com/yangming1996/p/9295168.html

注解是一种特殊的注释，用于修饰类、方法或变量，提供某些信息供程序在编译或运行时使用。

<font color="red">本质是一个继承了**Annotation接口**的接口</font>

例如：最出名的JDK内置注解@Override：

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}

//实际上继承了Annotation接口：

public interface Override extends Annotation{

}
```

上面的那两个@Target、@Retention是“元注解”，也就是修饰注解的注解，@Target指明了这个注解作用的目标（Override是类）、@Retention指明了当前注解的生命周期（Override是编译期可见），另外元注解还有@Inherited（表明这个注解可被继承）等

注解的解析方法：

- **编译期直接扫描：**编译期在编译java代码时扫描对应的注解并处理，如`@Override`，编译器在编译时就会检测当前的方法是否重写了父类对应的方法
- **运行时通过反射处理：**一些框架自带的注解，如Spring框架的@Autowired等、@Value、@Component等。

### 18.编译型语言和解释型语言

编译型语言：通过编译器将源代码一次性编译为针对某平台的机器码，然后直接可以在对应的操作系统上执行机器码。好处：执行速度快（执行的时候直接执行机器码）；缺点：开发效率低，代码移植性较差，针对不同平台需要编译多次。举例：C、C++、Go、Rust

解释型语言：执行的时候，通过解释器一句句将代码解释为机器码执行。好处：开发效率高，移植性好；缺点：执行的时候要解释，速度慢。举例：python、javascript、php

<font color="red">java是编译和解释并存的语言</font>——先通过编译器将源代码编译为字节码，然后在不同的平台执行时被加载到JVM后由不同的解释器解释为机器码执行。

### 19.JIT

![image-20231107153853562](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231107153853562.png)

JIT是 just in time 的缩写, 也就是**即时编译编译器**。使用即时编译器技术，能够加速 Java 程序的执行速度。

一般的java程序执行过程：

1. 编译期通过javac命令将.java源文件编译为.class字节码二进制文件

2. JVM得到字节码文件，通过类加载器加载到内存，验证.class文件符合JVM规范后，java解释器（JVM的一部分）就会逐条解释字节码文件，将其翻译为机器指令执行

   【也就是说解释是在JVM启动后才开始的，不同平台的JVM（如JVM for windows、JVM for Mac等）都可以解释同样的.class文件，实现了java程序的跨平台移植】

JIT的改进：

有一些被执行过很多次的字节码，解释器需要反复多次将同样的字节码进行解释，很浪费时间，这时候会将这种热点代码直接推送给JIT，让JIT编译为机器指令然后存到缓存，后面要执行那一部分的时候直接去缓存里拿机器指令就可以了，不需要解释器反复解释了。

### 20.静态代码块、构造代码块、构造函数、普通代码块的执行顺序

<font color="red">**顺序：静态代码块→构造代码块→构造函数→普通方法**</font>

```java
public class Parent {
    /**
    * 静态代码块
    **/
    static {
        System.out.println("父类的静态代码块执行");
    }
    /**
    * 构造代码块
    **/
    {
        System.out.println("父类的构造代码块执行");
    }
    /**
    * 构造函数
    **/
    public Parent(){
        System.out.println("构建父类的构造函数");
    }
    /**
    * 普通方法
    **/
    public void method(){
        System.out.println("调用父类的方法");
    }
}

```

如果B是A的子类且他们都有这三种类型，现在new 一个B对象并调用这个对象的方法，执行顺序为：

1. A的静态代码块
2. B的静态代码块
3. A的构造代码块
4. A的构造函数
5. B的构造代码块
6. B的构造函数
7. B的普通代码块

上面1、2步是A加载阶段，3-4是创建一个A对象，5-6是创建一个B对象，7是执行B对象的方法

如果接下来又new了第二个B对象，接下来会执行：

1. A的构造代码块
2. A的构造函数
3. B的构造代码块
4. B的构造函数

#### 静态代码块

- <font color="red">在类加载时自动调用，所以一般情况只被调用一次，除非遇到Class.forName(...)，就会再次被调用</font>
- 可以在类的任何位置，但不能在方法体中，只能访问类的静态变量
- 如果有多个静态代码块，则按照书写顺序依次调用

#### 构造代码块

- <font color="red">**每次实例化一个类的对象都会被调用**</font>，且先于构造函数，也就是<font color="red">无论调用的是哪个构造函数，都会在之前执行一遍这个构造代码块</font>
- 构造代码块也可以有很多个，<font color="red">按书写顺序执行</font>，可以写在类的任何位置，除了方法体里

#### 构造函数

- <font color="red">每new一个对象就调用相应的构造函数</font>
- 所有的构造函数执行之前都会执行它的所有构造代码块

#### 普通代码块

就是一般写在方法体里的，要显示调用那个方法才会调用

### 21.this和super

- 两个都是针对对象的，其中this代表对本对象的引用，super代表对父类对象的引用，<font color="red">因此不能放在static方法中</font>

- 在<font color="red">构造函数</font>中使用<u>super(xx)调用父类的其他构造方法，或者用this(xxx)调用本类中的其他构造方法时</u>，<font color="red">super(xxx)或this(xx)都必须处于首行，因此在同一个构造方法中不能同时用super(xxx)或this(xxx)</font>


### Exception和Error、受检查异常和不受检查异常的区别

Error和Exception都是java.lang.Throwable类的子类

- Exception：程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。
  - 受检查异常和不受检查异常：
    - Checked Exception（受检查异常）：必须要用catch或throws关键字处理这种异常，否则没发通过编译。除了`RuntimeException`及其子类以外，其他的`Exception`类及其子类都属于受检查异常 。
    - Unchecked Exception（不受检查异常）：不需要用catch或throws关键字处理也能通过编译。常见的有空指针异常（`NullPoiterException`）、参数异常（`IllegalArgumentException`）等。
- Error：程序无法处理的错误，如虚拟机内存不够错误(`OutOfMemoryError`)、栈溢出错误（`StackOverFlowError`）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止，可以通过catch捕获但不建议。

## JVM

### 1、JVM运行时数据区

管理内存有五大区域：方法区、堆、栈、本地方法栈、程序计数器

其中方法区和堆是所有线程共享的，栈，本地方法栈和程序计数器则为线程私有的

- **程序计数器：**线程私有，<font color="red">存下一条要执行的指令地址</font>。为了线程切换可以恢复到正确执行位置
- **栈（虚拟机栈）：**线程私有，<font color="red">每个方法被执行的时候都会创建一个栈帧用于存储局部变量表</font>，每一个方法被调用的过程就对应一个栈帧在栈中从入栈到出栈的过程。包括几部分：
  - 局部变量表：存<font color="red">基本数据类型局部变量</font>、<font color="red">包装类对象的<u>引用</u></font>
  - 操作数栈：存放方法执行过程中产生的<font color="red">中间计算结果、计算过程中产生的临时变量</font>
  - 动态链接：一个方法可能会调用别的方法，动态链接存的就是这些被调用的其他方法<font color="red">在运行时常量池中的引用</font>，当要调用别的某个方法时，通过这个引用到对应的运行时常量池处获取对应的方法的直接引用（在类加载阶段运行时常量池已将符号引用->直接引用）。
  - 返回地址

- **本地方法栈：**与虚拟机栈发挥的作用十分相似，区别是，本地方法栈为虚拟机使用到的native方法服务（调用底层c代码）
- **堆：**堆是java虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制。它的目的是存放对象实例，也是GC所管理的主要区域（字符串常量池在JDK1.8后放到了堆中）
- **方法区（jdk8之前方法区的实现是永久代，jdk8后变为了元空间（本地内存））：**同堆一样，是所有线程共享的内存区域。用于存储已被虚拟机加载的<font color="red">类信息、常量的引用、静态变量的引用、即时编译器编译后的代码等数据</font>。如static修饰的变量加载类的时候就被加载到方法区中（运行时常量池也在这里面)。<font color="orange">原本字符串常量池、运行常量池都在方法区，JDK8后将字符串常量池移到了堆中</font>

### 2、对象在堆里的分配

- <font color="red">对象优先在新生代中的eden区分配</font>，当eden区没有足够空间时，发起一次minor gc

- <font color="red">大对象直接进入老年代</font>，如需要大量连续内存空间的对象，如字符串、数组等

  【G1回收器根据`-XX:G1HeapRegionSize`（G1把内存区域分为好几个region，每个region的大小）参数设置的堆区域大小和`-XX:G1MixedGCLiveThresholdPercent`（存活对象低于这个阈值的region才能被回收）参数设置的阈值，来决定哪些对象会直接进入老年代；

  ​	Parallel Scavenge回收器默认情况下，并没有一个固定的阈值，由虚拟机根据当前堆内存情况和历史数据决定】

- <font color="red">对象如果长期存活那也会进入老年代</font>：虚拟机给每个对象一个年龄计数器，初始在eden分配时为0，晋升到survior为1，在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，然后每在survivor熬过一次minor gc就+1，Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 `-XX:TargetSurvivorRatio=percent` 来设置，），取这个年龄和`-XX: MaxTenuringThreshold` （大多数垃圾回收器默认15）中更小的一个值，作为新的晋升年龄阈值

### 3、GC过程

![](https://yangyujia.oss-cn-beijing.aliyuncs.com/jvm%20gc2.PNG)

创建对象时会优先在eden区分配空间，如果eden区空间不足，触发<font color="red">**young GC（minor GC）**，用来回收eden已有的对象，为新对象创建空出位置</font>。

minor GC之前，要判断<font color="red">老年代最大可用的连续空间是否大于新生代所有对象总空间</font>（做这个判断的原因是万一survior存不下，survior中的部分数据会来到老年区，这个检查是提前做准备）：

- 够的话<font color="red">直接minor GC</font>就可以了（ GC 完 survivor 不够放，老年代也绝对够放 ）。

- 不够的话判断是否通过 <font color="orange">-XX:-HandlePromotionFailure </font>参数开启了<font color="voilet">允许分配担保失败</font>：

  - 如果未开启，那<font color="red">直接full GC</font>

  - 如果开启了，那根据<font color="voilet">分配担保规则—— 如果老年代最大可用的连续空间大小>历次 minor GC 进入老年代的对象的平均大小，那就允许进行 minor GC</font>f

    - 若否，则进行<font color="red">full GC</font>

    - 若是，则进行<font color="red">minor GC</font>

      【需要注意的是，这个规则只是从概率上保证直接进行minor GC能够成功，但也有可能失败，所以后面的minor GC过程中也有可能老年代放不下】

      下面讲述后面minor GC的过程：

      - 如果eden要清除的数据survior放得下，那就放入survior
      - 如果eden要清除的数据survior放不下了，那要移动一部分进入老年代：
        - 如果老年代放得下，那就<font color="red">移动一部分进入老年代</font>
        - 如果老年代放不下，那就<font color="red">full GC</font>
        - 如果full GC之后也放不下了，那只能<font color="red">OOM</font>了

【注意，在JDK 6 Update24之前才有这么复杂的一大段判断，<font color="voilet">JDK 6 Update24之后的规则变为只要老年代剩余的最大可用连续空间大于新生代对象总大小，或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC</font>，不过当然在正常进行minor GC的时候也可能老年代不够用而发生full GC】

### 4、GC时的对象死亡判断方法和对象回收算法

#### 对象死亡判断方法

在java gc中，在进行回收之前要先判断对象是否死亡，主要有引用计数法和可达性分析算法两种方法。

- **引用计数法（jdk1.2及以前有用，现在已不用，python用的比较多）**：给对象添加一个<font color="red">引用计数器</font>，每有一个引用计数器就+1，引用失效了计数器就-1，计数器为0了就表示该对象死亡（缺点：会存在对象相互引用导致计数器不可能为0的情况，以及在多线程场景下改变计数值时还需要加锁）。

- **可达性分析算法**：通过一系列的<font color="red">GC Roots对象（如本地方法栈中引用的对象、方法区中类静态变量/常量引用的对象等）</font>作为起点，如果通过引用链无法到达某个对象，那么该对象就可以被回收，但不一定会马上被回收，<u>如果这个对象没有重写finalize方法或者finalize方法被调用过了</u>，那么马上就会回收这个对象；<u>如果这个对象重写了finalize方法且finalize方法没有被调用过</u>，才会将这个对象放入一个队列中（注意只是放入一个队列中，不是马上就被回收了），当第二次标记还是不可达的话，才真的被回收

  可以作为GC Roots的对象：

  - 虚拟机栈中引用的对象，如局部变量
  - 方法区中类静态成员变量、常量引用的对象
  - 所有被同步锁synchronized持有的对象
  - JNI(java native interface，也就是本地方法)引用的对象
  - 一些常驻的异常对象（如空指针异常、OOM异常）
  - 系统自带的类加载器
  - <font color="orange">小技巧——所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root</font>

  可达性分析算法的提速策略：

  - ????????搜都搜不到啊

#### 对象回收算法

- **标记-清除法：**首先标记出<font color="red">不需要清除的对象</font>，之后统一回收<font color="red">所有没有被标记的对象</font>。缺点：会产生很多内存碎片。

- **标记-整理法：**和标记清除法相比不是直接回收掉没标记的对象，而是先<font color="red">把不用回收的对象整理到内存的一侧，之后把这一侧以外的内存都给清理了</font>。好处：不会产生内存碎片。

  - 什么情况下适合用标记-整理法：1.不能浪费太多内存空间（如老年代） 2.标记时存活下来的对象多  

- **标记-复制法：**将内存分为大小相同的两块A、B，交替使用其中一块，每次要清理时A，<font color="red">把A中所有不用清除的对象移到B，然后清理A</font>，下一次用的就是B，清理B的时候同理。

  - 什么情况下适合用标记-复制法：1.每次标记时存活下来的对象少，这样就不用复制那么多过去 2.可以浪费一定的内存空间    

  <font color="red">**新生代使用标记-复制法**</font>（原因：对象的存活率低，可以不用复制那么多过去，而且由于有分配担保机制，可以浪费一定的空间，并且新生代的垃圾回收频繁，标记-复制法较为简单高效）。<font color="red">**老年代使用标记-清除或标记-整理**</font>（原因：标记时存活下来的对象多，如果用标记-复制法那会复制太多对象，效率低，没有额外空间给老年代进行分配担保，所以不能使用标记-复制这种对内存消耗较大的算法）。

- **分代收集算法**：“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法

JDK8默认垃圾回收器：Parallel Scavenge（新生代【标记-复制算法】） + Parallel Old（老年代【标记-整理算法】）

#### 常用的垃圾回收器

JDK8新生代默认用**Parallel Scavenge**，老年代用**Parallel Old**，JDK9-20全部都用的G1

**Serial（新生代标记-复制，老年代标记-整理）**

<font color="red">只用一条线程进行GC，且GC的时候会暂停所有用户线程</font>

**ParNew（新生代标记-复制，老年代标记-整理）**

serial的多线程版本，<font color="red">用多条线程并行进行GC，但GC的时候也会暂停所有用户线程</font>

**Parallel Scavenge（只针对新生代，标记复制）**

和Parnew基本一样，但关注<font color="red">吞吐量</font>（用户线程执行时间占CPU总时间的比值，GC消耗时间百分比越小吞吐量越大），提供了很多参数用来设置指定的吞吐量，如控制最大垃圾收集停顿时间的`-XX:MaxGCPauseMillis`参数以及直接设置吞吐量大小的`-XX:GCTimeRatio`参数

**Parallel Old（只针对老年代，标记整理）**

Parallel Scavenge老年版本，标记整理

**CMS（标记清除，第一款真正意义上实现GC线程和用户线程基本同时工作的垃圾回收器，jdk9已废弃）**

![CMS 收集器](https://oss.javaguide.cn/github/javaguide/java/jvm/cms-garbage-collector.png)

四阶段：

1. 初始标记（STW)：<font color="red">只有GC相关线程</font>，记录<u>直接和GC Roots相连的对象</u>，速度很快
2. 并发标记：<font color="Red">有GC相关线程和用户线程</font>，GC相关线程<font color="Red">用一个闭包结构标记从GC Roots可达的对象</font>，但因为用户线程可能不断在更新对象的引用，所以这个阶段结束后闭包无法保证包含了当前所有的可达对象，因此<font color="red">在标记过程中会记录发生引用更新的地方</font>
3. 重新标记（STW）：<font color="red">只有GC相关线程</font>，根据之前记录的那些发生引用更新的地方，<font color="Red">修复上一个阶段由于用户线程一边更新对象引用导致最终标记不一致之处</font>
4. 并发清除：<font color="Red">有GC相关线程和用户线程</font>，GC线程对刚才未标记的对象进行清除

**G1（整体标记整理，局部标记复制）**

![G1 收集器](https://oss.javaguide.cn/github/javaguide/java/jvm/g1-garbage-collector.png)

G1不要求新生代、老年代用连续空间实现，而是把堆分为一个个小<font color="red">region</font>，每个region可能是新生或老生，也可能就没用到什么都不是，可以通过设置参数来设置每个region的大小，<font color="orange">会根据用户设置的最大停顿容忍时长来进行region的动态分配</font>（能够容忍的时长越长那么一般分给新生代的region个数会越多，因为新生代的垃圾回收是对新生代region进行，这些region越多那么回收时间也就越长，另一方面G1的minor gc之所以快也是因为它的回收区域是动态选择的，不像别的minor gc就是直接回收一整个固定的新生代空间）

也是四阶段，前三阶段和CMS基本相同，重点是最后一个阶段的区别：

1. 初始标记（STW)：<font color="red">只有GC相关线程</font>，记录<u>直接和GC Roots相连的对象</u>，和CMS同
2. 并发标记：<font color="Red">有GC相关线程和用户线程</font>，也是标记所有可达对象的过程中记录发生引用更新的地方，和CMS同
3. 最终标记（STW）：<font color="Red">只有GC相关线程</font>，和CMS类似，也是修复标记中不一致之处
4. 筛选回收（STW)：<font color="Red">只有GC相关线程</font>，制定回收计划，<font color="Red">根据用户设置的最大停顿时间选择那些回收效益最大的region，然后把要回收的Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间</font>。

### 5、类加载、类卸载相关

#### 类的加载过程：

1. **加载（通过类加载器完成，具体用哪个类加载器由双亲委派模型决定，在方法区中生成对应的结构）**

- 通过类的全限定名获取这个类的.class文件，并加载二进制字节流
- 然后在<font color="red">方法区</font>创建一个运行时数据结构，存各种类信息
- 然后在<font color="Red">堆</font>中生成一个<font color="red">代表该类的 `java.lang.Class` 对象（包含类名和类加载器两部分，因此若类加载器不同那JVM也会把它当成两个不同的类对象）</font>，作为方法区该类的各种数据的访问入口

 **2.验证（目的是确保class文件中的字节流包含的信息符合《java虚拟机规范》的要求）**

- class文件格式验证
- 字节码语义检查
- 程序语义检查
- 类的正确性检查

(第一个直接检查<font color="red">class文件</font>，主要为了保证输入的字节流能正确地解析并存储于方法区，后三个阶段检查的是<font color="red">方法区里的存储结构</font>)

 **3.准备（为类的静态变量分配内存并设置默认初始值）**

需要注意的点：

- 现在只分配<font color="red">类的静态变量</font>，也就是用static关键字修饰的变量，<font color="red">不分配实例变量</font>
- 类的静态变量的<font color="red">引用</font>放在<font color="red">方法区</font>，<font color="red">实际对象</font>在JDK8之后放到<font color="red">堆</font><font color="blue">【JDK8之后原来在方法区的字符串常量池和静态变量对象都放到了堆中】</font>
- <font color="red">设置的是数据类型的默认初始值而不是用户赋予的初始值</font>，比如我们定义了`public static int value=111` ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值），如果是引用类型的话就是null。特殊情况：比如给 value 变量加上了 <font color="Red">final </font>关键字`public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111。

**4.解析（也就是静态链接，<font color="red">将常量池内的符号引用替换为直接引用</font>，例如将方法的符号引用替换为这个方法的实际地址)**

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。

**符号引用：**一个符号，通过该符号能够唯一找到这个东西

**直接引用：**那个东西的直接地址

<font color="Red">这一步是可选的，对应的就是类加载器里loadClass方法的resolve这个参数，如果是true的话才进行解析</font>

 **5.初始化（执行初始化方法 `<clinit> ()`，开始真正执行类中定义的 Java 程序代码，注意需要满足一些条件，如该类包含main函数、该类被new一个对象、对该类进行反射调用等）**

只有这6种情况，主动去使用类了，才会去初始化类，（注意类加载≠类的初始化，一开始所有类都会加载并完成以上四个步骤，但要满足下面的条件才会做初始化这步）：

1. 遇到<font color="red"> `new`</font> 、 `getstatic`、`putstatic` 或 `invokestatic` 这 4 条直接码指令时
2. 使用 `java.lang.reflect` 包的方法<font color="red">对类进行反射调用时</font>如 `Class.forname("...")`等
3. <font color="red">如果其父类还未初始化，则先触发父类的初始化</font>
4. 当虚拟机启动时，<font color="red">包含 `main` 方法的那个类会先被初始化</font>
5. `MethodHandle` 和 `VarHandle` 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 `findStaticVarHandle` 来初始化要调用的类
6. 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化

【注意：<clinit>()是初始化类，注意不是对象构造器，<init>()才是对象构造器，类有几个构造方法就有几个对象构造器】

#### 类卸载：

**卸载类即该类的class对象被GC。**

卸载类需要满足 3 个要求:

1. <font color="red">该类的所有的实例对象都已被 GC</font>，也就是说堆不存在该类的实例对象。
2. <font color="red">该类没有在其他任何地方被引用</font>
3. <font color="red">该类的类加载器的实例已被 GC</font>

所以，在 JVM 生命周期内，由<font color="red"> **jvm 自带的类加载器加载的类**是不会被卸载的</font>。但是<font color="red">**由我们自定义的类加载器加载的类**是可能被卸载的</font>。

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvMTIyMzMyOC8yMDE3MDgvMTIyMzMyOC0yMDE3MDgyMTE0MDAyNjkzMy02MTM5MzIxODUucG5n?x-oss-process=image/format,png)

loader1变量和obj变量间接应用代表Sample类的Class对象，而objClass变量则直接引用它。

　　如果程序运行过程中，将上图左侧三个引用变量都置为null，此时Sample对象结束生命周期，MyClassLoader对象结束生命周期，代表Sample类的Class对象也结束生命周期，Sample类在方法区内的二进制数据**被卸载**。

　　当再次有需要时，会检查Sample类的Class对象是否存在，**如果存在会直接使用，不再重新加载**；如果不存在Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表Sample类的Class实例(可以通过哈希码查看是否是同一个实例)。

#### 类加载器相关

类加载器是一个负责加载类的对象，java.lang.ClassLoader是所有类加载器所继承的抽象类，给定类的二进制名称，每一个java类都有一个引用指向加载它的ClassLoader（数组类不是通过ClassLoader创建的，是JVM直接生成的）。

类加载器的主要作用是<font color="red">**通过类名获得相应java类的字节码（.class文件），然后加载该字节码到JVM中，在内存中生成一个代表该类的Class对象**</font>，字节码（.class文件）可以是.java文件经过编译得来，也可以是通过工具动态生成或通过网络下载得来。

##### 类加载器加载规则

- 大部分类在使用到的时候才会加载，而非一次性加载所有的类。
- 已加载的类会存在ClassLoader中，在类加载的时候系统会先判断这个类是否已被加载过，如果被加载过那会直接返回，否则才会尝试加载。

##### JVM内置类加载器

- **BootstrapClassLoader（启动类加载器，是一个native方法）：**最顶层的加载类，没有父级，主要用来加载<font color="red">JDK内部的核心类库</font>（ `%JAVA_HOME%/lib`目录下的 `rt.jar` 、`resources.jar` 、`charsets.jar`等 jar 包和类）以及被 `-Xbootclassloader`参数指定的路径下的所有类。<font color="red">包名开头为java、javax、sun开头的类都由它加载</font>

- **ExtClassLoader（扩展类加载器，即ExtClassLoader这个类）：**主要负责加载java的<font color="red">扩展类库</font>： `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。

- **AppClassLoader(应用程序类加载器，即AppClassLoder这个类)** ：面向用户的类加载器，负责加载<font color="red">当前应用 `java.class.path(当前java工程目录bin，存放编译的.class文件)`下的所有 jar 包和类</font>。 <font color="red">如果没有自定义类加载器的话，用来加载用户写的类的类加载器就是AppClassLoader</font>。AppClassLoader 可以由 ClassLoader 类提供的静态方法 getSystemClassLoader() 得到

  【<font color="voilet">用户自定义的类加载器的父类加载器是AppClassLoader，AppClassLoader父类加载器是ExtensionClassLoader，ExtensionClassLoader的父类加载器是BootstrapClassLoader</font>。注意“父类加载器”不是以继承的方式体现（除了BootstrapClassLoader外其它类加载器都继承自ClassLoader），而是以组合的形式体现，也就是每个ClassLoader类中都有一个<font color="red">parent属性</font>表明它的父加载器】

<font color="orange">当编写了一个名为xxx的类时，可以通过**xxx.class.getClassLoader()**来得到这个类的类加载器</font>

除了BootstrapClassLoader是由C/C++实现的之外，其他类加载器都继承自java.lang.ClassLoader

##### 自定义类加载器

需要继承<font color="red">java.lang.ClassLoader</font>这个抽象类，<u>如果不想打破双亲委派模型的话重写ClassLoader中的<font color="orange">findClass()</font>方法即可，如果想打破的话需要重写<font color="orange">loadClass()</font>方法和<font color="orange">findClass()</font>方法</u>

- `protected Class loadClass(String name, boolean resolve)`：加载指定二进制名称的类，<font color="red">实现了双亲委派机制</font> 。`name` 为类的二进制名称，`resolve` 如果为 true，会调用 `resolveClass(Class<?> c)` 方法对类进行链接。
- `protected Class findClass(String name)`：根据类的二进制名称来查找类，默认实现是空方法，如果要重写的话，必须在里面实现加载类的字节码文件，获取得到二进制流byte[]，然后再return defineClass 得到一个Class<?>。

#### 双亲委派机制

**原理：**ClassLoader在查找类之前，会先将这个查找类的任务委托给它的父类加载器来完成，父类加载器无法完成的话再自己完成。

**过程（在ClassLoader的<font color="red">loadClass()方法</font>里实现）：**

1. 首先判断这个类是否被加载过，如果已被加载过那直接返回，否则进入下一步

2. 通过<font color="red">parent是否为null</font>判断当前的类加载器的父类加载器是否为空，为空的话说明该类加载器是ExtensionClassLoader，调用findBootstrapClassOrNull(name)方法进行加载（就是调用本地native进行加载，启动类加载器是一个本地方法而不是一个实际的类）；不为空的话<font color="red">调用parent的loadClass()方法</font>得到该类，<font color="red">在该方法里执行的也是这一系列过程</font>。所有的请求最终都会传送到顶层的BootstrapClassLoader中。

3. 如果父类加载器无法找到相应的类，那这个类加载器才会调用自己的<font color="red">findClass(name)</font>方法来进行加载。

   

【双亲委派机制的意义：】

1. 沙箱安全：自定义的核心类不会加载，有效防止核心API库被篡改，保证了代码的安全性。
2. 避免不必要的类被重复加载：当父类加载器过某个类，子类加载器不需要再加载。

#### ！！！！！关于打破双亲委派模型的一个注意的点

在面淘天一面的过程中，我被问到了如何打破双亲委派模型，我当时答的是重写loadClass方法（因为javaguide里也这么写），但面试官说不对，面试结束后我自己试了一下，发现确实是不对的

我原来是这么写的，就是重写了loadClass方法：

这里需要注意的点是**loadClass可以不重写（重写了的话要注意java.开头的包一定要用启动类加载器加载），但一定要重写findClass，如果不重写loadClass，那parent设为null**

- 重写findClass的原因：抽象类ClassLoader的findClass方法是空的，findClass里面注意两步：<font color="red">先读取要加载的类所对应的.class文件为二进制字节流byte[]，对应的就是loadClassData这个方法，然后调用defineClass这个native方法把构建为一个class</font>

- loadClass可以不重写，就算重写也要注意java.开头的包一定用启动类加载器加载的原因：所有类都是Object的子类，加载完自定义类之后都会去加载Object这个类，并且还是用的同一个自定义类加载器，但JDK规定<font color="red">java.开头的类都只能由启动类加载器加载，否则就会报错，所以一定得包含双亲委派的逻辑，让启动类加载器加载java.lang.Object</font>

- 如果不重写loadClass，自定义类加载器的parent设为null的原因：打破双亲委派机制，直接让启动类加载器加载类

  跳过 自定义加载器→AppClassLoader→ExtClassLoader→BootStrapClassLoader这个过程，直接变为了 自定义类加载器->BootStrapClassLoader

```java
public class MyClassLoader extends ClassLoader{
    
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try{
            byte[] bytes=loadClassData(name);//通过类名，加载类的.class字节码文件为二进制字节流
            return defineClass(name,bytes,0,bytes.length);//调用 native 方法把 Java 类的字节码解析成一个 Class 对象
        }catch (Exception e){
            e.printStackTrace();
            throw new ClassNotFoundException();
        }
    }

    @Override
    public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        Class<?> loadedClass=this.findLoadedClass(name);
        if(loadedClass!=null){
            return loadedClass;
        }
        else{
            try{
                //打破双亲委派模型，直接findClass
                Class<?> aClass=this.findClass(name);
                if(resolve){
                    this.resolveClass(aClass);
                }
                return aClass;
            }catch (Exception e){
                return super.loadClass(name,resolve);//如果出错了再用超类的loadClass
            }
        }
    }

    //读取Class文件作为二进制流放入byte数组, findClass内部需要加载字节码文件的byte数组
    private byte[] loadClassData(String name) throws IOException {
        name = name.replace(".", "\\"); // 为了定位class文件的位置，将包名的.替换为/
        System.out.println(name);
        FileInputStream fis;
        byte[] classBytes;
        fis=new FileInputStream("F:\\找工作\\星环\\8.6笔试\\src\\"+name+".class");
        int length=fis.available();
        classBytes=new byte[length];
        fis.read(classBytes);//读取class文件作为二进制流放入byte数组中
        fis.close();
        return classBytes;//返回该byte数组
    }
}

```

要加载的User类和测试类：

```java
package testClassloader;

public class User {
    private String name;
    public String getName(){
        return name;
    }
}
```

```java
package testClassloader;

public class TestClassLoader {
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        MyClassLoader myClassLoader=new MyClassLoader();//创建一个自定义类加载器
        Class<?> aclass=myClassLoader.loadClass("testClassloader.User");//使用自定义的类加载器加载User这个类
        Object o=aclass.newInstance();//实例化一个User的对象
        System.out.println(o);//打印出这个对象
        System.out.println(o.getClass().getClassLoader());//打印出这个类的类加载器
    }
}
```

但这样发现有报错：

![image-20230810003235275](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230810003235275.png)

这是因为java中所有类都继承了Object，而加载自定义子类之后还会加载Object，并且还是用自定义的类加载器，而Object.class不在对应的文件夹下，所以系统找不到文件

但是即使把Object.class放到对应的文件夹下也会报错，爆的是以下的错误：![image-20230810003652496](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230810003652496.png)

意思是java禁止用户用自定义的类加载器加载`java.`开头的官方类，也就是说只有启动类加载器`BootstrapClassLoader`才能加载`java.`开头的官方类（Object完整包名为java.lang.Object）

解决方法：将MyClassLoader的父类加载器设为null，且不重写loadClass方法，这样当执行loadClass方法时发现parent为null，就会去调用findBootstrapClassOrNull去加载这个类，当要加载Object时，启动类加载器直接就加载了，当要加载User时，启动类加载器加载不了，才交给MyClassLoader加载，这样做到了跳过AppClassLoader和ExtClassLoader

完整代码：

- 自定义类加载器

```java
package testClassloader;

public class MyClassLoader extends ClassLoader{
    public MyClassLoader(ClassLoader p){
        super(p);
    }
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try{
            byte[] bytes=loadClassData(name);//通过类名，加载类的.class字节码文件为二进制字节流
            return defineClass(name,bytes,0,bytes.length);//调用 native 方法把 Java 类的字节码解析成一个 Class 对象
        }catch (Exception e){
            e.printStackTrace();
            throw new ClassNotFoundException();
        }
    }

    //读取Class文件作为二进制流放入byte数组, findClass内部需要加载字节码文件的byte数组
    private byte[] loadClassData(String name) throws IOException {
        name = name.replace(".", "\\"); // 为了定位class文件的位置，将包名的.替换为/
        System.out.println(name);
        FileInputStream fis;
        byte[] classBytes;
        fis=new FileInputStream("F:\\找工作\\星环\\8.6笔试\\src\\"+name+".class");
        int length=fis.available();
        classBytes=new byte[length];
        fis.read(classBytes);//读取class文件作为二进制流放入byte数组中
        fis.close();
        return classBytes;//返回该byte数组
    }
}
```

- 要加载的类

```java
package testClassloader;

public class User {
    private String name;
    public String getName(){
        return name;
    }
}
```

- 测试类

```java
package testClassloader;

public class TestClassLoader {
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        MyClassLoader myClassLoader=new MyClassLoader(null);//这里传入null，这样做到了跳过AppClassLoader和ExtClassLoader
        Class<?> aclass=myClassLoader.loadClass("testClassloader.User");
        Object o=aclass.newInstance();
        System.out.println(o);
        System.out.println(o.getClass().getClassLoader());//打印出这个类的类加载器
    }
}
```

#### Tomcat的自定义类加载器

Tomcat要自定义类加载器的原因：

1. 实现不同应用的类隔离：Tomcat中需要部署很多个应用，但是两个应用中可能会出现一样的类名，<font color="red">Tomcat启动之后其实是一个java进程，不管里面部署了多少个应用</font>，所以如果只有一个默认的AppClassLoader，就只能加载一个同名的类了，会有问题。所以Tomcat中会为部署的每个应用生成一个<font color="red">WebAppClassLoader类加载器实例</font>加载这个应用里的类
2. 利用自定义类加载器实现热加载：热加载是当这个类有更新时不需要重启应用就能重新加载这个类

![Tomcat 的类加载器的层次结构](https://oss.javaguide.cn/github/javaguide/java/jvm/tomcat-class-loader-parents-delegation-model.png)

- CommonClassLoader：加载tomcat里部署的web应用以及tomcat内部都使用的公共类
- CatalinaClassLoader：加载tomcat内部使用的类（部署的应用不可见）
- SharedClassLoader：加载部署的应用共用的类
- WebAppClassLoader：加载每个应用各自独立使用的类

### 6、内存泄漏和内存溢出

**内存泄漏(memory leak) **指向系统申请了分配内存但使用完了未归还，导致申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。<font color="orange">内存泄漏堆积的话最终会导致内存溢出</font>.

java中可能会发生内存泄漏的场景（其实也就是无法被gc的场景）：

- 没有及时将不用的强引用对象设为null
- IO连接、数据库连接、网络连接等资源未关闭（可以使用try-with-resources避免）
- 长生命周期的对象持有短生命周期的引用：如类的静态成员变量所引用的对象都是要等到程序结束才会被回收，如果这个静态成员变量引用的对象很多（比如说这个静态成员变量是一个集合，虽然可能后面不用这个集合了，但是因为被静态成员变量引用了，所以都不会被回收），那么就很容易导致内存泄露的堆积

解决方法：

- 及时把不用的引用设为null
- 使用弱引用
- 避免过度使用静态集合的成员变量
- 及时关闭IO等资源

**内存溢出（OOM）**指程序在申请内存时，没有足够的内存空间供其使用。

会发生OOM的场景：

- 代码死循环
- 在循环中new了过多对象
- 内存中加载的数据量过于庞大，如一次性从数据库取出过多数据
- 启动参数内存值设定的太小

解决方法：

生成dump快照文件（可使用jmap命令在任意时刻生成，或-XX:+HeapDumpOnOutOfMemoryError命令在发生OOM时自动生成），然后使用jdk自带的jhat或jvisualvm分析dump文件，找出占用空间过大的对象。<font color="green">具体见后面场景提，有详细描述</font>

## 集合

![Java 集合框架概览](https://oss.javaguide.cn/github/javaguide/java/collection/java-collection-hierarchy.png)

### 1、有哪些常用的集合，这些集合下面有哪些常用的类型

List、Set、Queue、Map

<font color="red">【注意List、Set、Queue是Collection接口下面的，Map不是】</font>

**List：（用于需要顺序的情况）元素有序、可重复**。

- Vector：Object[] 数组（线程安全，使用synchronized关键字进行处理，Stack继承自Vector）

- ArrayList： Object[] 数组

- LinkedList： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)

**Set：（用于要求元素不可重复的情况）元素无序、不可重复**

- HashSet(无序，唯一): 基于 HashMap 实现的，底层采用 HashMap 来保存元素

- LinkedHashSet（有序、唯一）: LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的 LinkedHashMap 其内部是基于 HashMap 实现一样，能够保证插入元素的顺序。

- TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树)，底层通过TreeMap实现

**Queue：（用于要求按特定规则排序的情况）元素按特定规则排序、有序、可重复**

- PriorityQueue: Object[] 数组来实现二叉堆，与一般Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。线程不安全

- PriorityBlockingQueue：线程安全版的PriorityQueue，共用一把ReentrantLock来保证线程安全

- ArrayQueue: Object[] 数组 + 双指针

- 【Queue还有一种子接口叫Deque，Queue是单端队列，元素只能从一段进、另一端出，Deque是双端队列，在队列的两端均可以插入或删除元素。】

- <font color="red">LinkedList这个类很特殊，既实现了List，又实现了Deque</font>

**Map：（用于处理键值对）处理键值对<key,value>，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。**

- HashMap

- LinkedHashMap（有序）：和HashMap相比增加了一条双向链表，使得可以保持键值对的插入顺序。

- HashTable

- TreeMap：红黑树（自平衡的排序二叉树）

### 2.有哪些线程安全的集合

List：

- Vector：get和add方法都用了synchronized修饰(注意是给这个方法加锁而不是给数组加锁)
- SynchronizedList：get和add方法都用了synchronized修饰（是对mutex这个成员变量加锁而不是对方法加锁）
- CopyOnWriteArrayList：只有写写互斥，读写和读读都不互斥，底层机制是添加元素时调用的add方法内部用一把ReentrantLock，添加元素之前reentrantLock .lock()，然后<font color="red">将原数组复制到一个长度增加1的新Object[]里，然后用这个新数组替换老数组</font>

map：

- HashTable
- ConcurrentHashmap

Set：

- CopyOnWriteArraySet

Queue：

- ConcurrentLinkedQueue：非阻塞队列，主要使用CAS非阻塞算法实现线程安全
- BlockingQueue：阻塞队列，也就是线程池里用的那些，主要通过ReentrantLock可重入锁等机制来保证线程安全

### 3.Queue中几对方法的对比

![image-20231003153724298](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231003153724298.png)

主要就是一个是否抛出异常的区别，为了减少异常的抛出，最好还是用offer、poll、peek

### 2、hashmap put

0.首先会判断数组是否为空或者长度是否为 0，为空或者长度为 0 就进行 resize 扩容操作（实例化hashmap的时候它的长度还是为0，要第一次放入元素的时候执行扩容它才会有长度，默认初始长度为16，如果传了长度参数的话会把长度转为最接近这个参数的2的幂次方）。
在插入键值对的时候调用一个名为 hash 的函数，
1.取 hash：先判断 key 是否为 null，如果为 null 直接令 hash=0,否则取得 key.hashcode，然后计算 hash=hashcode^(hashcode>>>16） <font color="red"> (其实就是hashcode的高16位和低16位做按位异或运算)</font>
2.算这个元素应该放到哪个数组下标：<font color="red">**index=hash&(数组长度-1）**</font>，实际上是做了 hash%数组长度的操作，但因为 hashmap 自动把数组长度变为 2 的幂次方，所以可以将耗时较长的取模操作转换为简单的位运算，结果都一样。
3.如果定位到的数组位置没有元素就直接放到数组对应位置。如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同直接得到对应的节点e，如果 key 不相同，就判断该位置的那个节点是否是一个树节点，如果是就调用<font color="red">e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value)</font>，在putTreeVal方法里也会比较对应key是否已经存在，如果存在的话会直接返回已有的这个树节点，如果不存在的话会新插入一个节点并返回null。如果不是红黑树节点就<font color="red">遍历链表，在遍历链表的过程中找是否有相同key的元素，有的话直接得到这个节点e，如果遍历到链表尾部还没找到key相同的节点的话就在链表尾部插入新节点</font>，并且插入之后判断链表长度是否<font color="orange">大于 8</font>，大于 8 的时候再判断数组长度是否<font color="orange">大于等于 64</font>，如果大于等于 64 则进行链表转红黑树的操作，否则调用 resize 对数组进行扩容。<font color="green">以上过程如果找到了key相同的节点那么e=那个节点，没找到的话会插入新节点且e=null</font>

4.<font color="red">根据e是否为null判断上一阶段是否找到了key相同的节点</font>，如果e不为null的话说明找到了key相同的节点，改变这个节点的value为新值，如果e=null的话表明上一阶段插入了新节点，不管

5.最后 size++<font color="red">（节点个数）</font>,如果<font color="orange">大于threshold（数组长度*loadFactor） </font>的话就 resize 扩容。
注意：扩容的时候是将数组扩容为原来的两倍，然后要遍历每个table元素，利用每个节点的 hash &(新数组长度-1) 得到新的数组下标

#### ！！！！有关链表转红黑树和红黑树转链表

<font color="red">链表转为红黑树：链表长度>8且数组长度≥64</font>

<font color="red">红黑树退化为链表：链表长度≤6（留两个阈值做缓冲，防止刚退化为链表又新来节点又要转为红黑树）</font>

### 3、hashmap扩容

会发生扩容的几种情况：

- 插入新节点之前table未初始化或长度为0
- 插入新节点后<font color="red">节点总数量>threshold</font>
- 插入新节点后使得<font color="red">节点所在链表长度>8但此时table长度＜64</font>

**扩容过程：**

0.建立及维护几个变量：旧数组长度oldCap、新数组长度newCap=oldCap\*2、旧扩容阈值oldThr、新扩容阈值newThr=oldThr\*2，如果发现oldCap为0，那说明table还没初始化，要先初始化然后直接返回，如果已经进行了初始化那再进行接下来的操作

1.建立<font color="red">一整个新数组</font>

2.循环遍历源数组table，把原table中每个链表中的每个元素放入新table

- 如果遍历到的该数组的入口节点e是单个节点，那直接计算它的新数组下标<font color="red">index=e.hash & (newCap - 1)</font>然后放进去就可以

- 如果该入口节点e是一个红黑树节点TreeNode，则调用<font color="red">((TreeNode<K,V>)e).split(this, newTab, j, oldCap)</font>

- 如果不是前面两种情况，即该入口节点e连着一个链表，那逐个遍历链表元素，用<font color="red">e.hash & oldCap是否为0</font>判断该元素的新位置【实际上也是e.hash & (newCap - 1)，但由于newCap是oldCap的两倍，所以新下标要么和原下标相同，要么是原下标+原数组长度，可以用e.hash & oldCap是否为0来计算，如果<font color="red">为0的话就是原下标，为1的话就是原下标+原数组长度</font>，在这个判断过程中为这个旧链表维护两个新链表，第一个链表是还放在原下标的，第二个链表是放到原下标+原数组长度的，在每个节点进行判断时都会将之放到对应的新链表里，然后最后把这两个新链表整个移到新数组对应的下标处

  上面的原理见下图：

  ![](https://yangyujia.oss-cn-beijing.aliyuncs.com/hash%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B.png)

3.返回整个新数组



### 4、hashmap为什么用红黑树、红黑树的好处

**红黑树特点** :

1. 每个节点非红即黑；
2. <font color="red">根节点总是黑色的</font>；
3. <font color="red">每个叶子节点都是黑色的空节点（NIL节点）</font>；
4. 如果节点是<font color="red">红色</font>的，则它的子节点必须是<font color="red">黑色</font>的（反之不一定），也就是说<font color="red">从叶子到根的路径不能有连续两个红色节点</font>；
5. 从任一个节点到它的每个叶节点的每条路径，必须包含<font color="red">相同数目的黑色节点（即相同的黑色高度）</font>；
6. 新插入的节点是<font color="red">红色节点</font>，后续可以通过变色变为黑色

**红黑树好处：**

是**<font color="red">自平衡的二叉查找树</font>**，正是由于红黑树的种种规定，使得红黑树<font color="red">从根到叶子的最长路径不会超过最短路径的2倍</font>，在hashmap中可以<font color="red">**提高查询效率**</font>

当插入或删除节点时，为了保证以上规则，红黑树需要进行一些调整：变色、左旋转、右旋转

**红黑树的应用** ：TreeMap（自排序的map）、TreeSet（自排序的set）、JDK1.8的HashMap。



#### 补充：红黑树和AVL树（平衡二叉树）

- AVL树是严格的平衡二叉树，<font color="red">保证左右子树高度不超过1</font>，当执行插入、删除操作时，一旦打破平衡就要做旋转，很耗时，但查找效率高，适用于<font color="red">插入删除不频繁、查找很频繁</font>的场景

- 红黑树的平衡条件为“一个红节点的子节点必须为黑节点”，如果不满足这个条件才进行调整，从而<font color="red">保证从根到叶子的最长路径不会超过最短路径的2倍</font>，没有AVL那么严格（左右子树的高度差不超过1），<font color="red">在插入和删除场景下效率比AVL更高</font>，查询场景下的效率也高。

  

### 5、ConcurrentHashmap如何保证线程安全？get的时候是否加锁？

JDK1.8前：segment分段机制，JDK1.8后：取消了分段，只对那一个桶进行加锁（且只在put的时候加锁，get的时候不加锁），加锁用CAS+synchronized

 **ConcurrentHashmap的结构：**

 **JDK1.8之前的**

![](https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png)

有一个Segment数组，这个segment数组类似一个hashmap，每个元素都是一个HashEntry数组的入口，<font color="red">HashEntry可以进行扩容。但`Segment` 的个数一旦**初始化就不能改变**，</font>默认 `Segment` 的个数是 16 个，也可以认为 `ConcurrentHashMap` 默认支持最多 16 个线程并发。

**JDK1.8及其之后的**

![](https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png)

可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 **Segment 数组 + HashEntry 数组 + 链表**，而是 **Node 数组 + 链表 / 红黑树**。当冲突链表达到一定长度时，链表会转换成红黑树。

get的时候不加锁，put的时候才加（结合synchronized和CAS）

#### ConcurrentHashmap的一些底层源码、如何使用synchronized和CAS

**JDK7**

数据结构：

- 有一个Segment<K,V>[] segments，其中Segment<K,V>是一个内部类，里面有一个成员变量HashEntry<K,V>[] table，也就是那个Segment连着的HashEntry数组（类似JDK7的Hashmap）
- 很多成员变量如Segment<K,V>的HashEntry<K,V>[] table、HashEntry<K,V>的value、next等都是用volatile修饰的，保证可见性
- 也有初始化容量（默认16）、负载因子（默认0.75），还多加了并发级别（默认16）

**JDK8**

**数据结构：**

- 取消了Segment<K,V>[] segments，而变为类似HashMap的Node<K,V>[] table

**初始化操作（initTable()方法，自旋+CAS）：**

```java
/**
 * Initializes table, using the size recorded in sizeCtl.
 */
private final Node<K,V>[] initTable() {
    Node<K,V>[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        //　如果 sizeCtl < 0 ,说明另外的线程执行CAS 成功，正在进行初始化。
        if ((sc = sizeCtl) < 0)
            // 让出 CPU 使用权
            Thread.yield(); // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings("unchecked")
                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                    table = tab = nt;
                    sc = n - (n >>> 2);
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}

```

- ConcurrentHashMap里面有一个被volatile修饰的参数sizeCtl，有以下几个含义：
  - -1：正在初始化——只能为一次-1，保证该ConcurrentHashMap只被初始化一次
  - -N：取N对应的二进制的低16位为M，此时有M-1个线程在进行扩容
  - 0：table初始化大小，如果table没有初始化
  - \>0：table扩容的阈值（默认为table大小的0.75倍），如果table已经初始化

1. 通过while<font color="red">自旋</font>，看当前table是否为null或者长度为0，如果是的话，再进行下面的操作
2. 读取sizeCtl的值，<font color="red">先判断它是否<0，是的话说明别的线程正在执行初始化/扩容，通过Thread.yield()让出CPU</font>，否则再进行接下来的操作
3. 然后进行<font color="red">CAS操作：判断共享内存中sizeCtl的值是否等于刚才读取的这个sizeCtl预期值，是的话将共享内存中的sizeCtl的值改为-1</font>，并进行table初始化操作，具体为判断刚才读取到的sizeCtl值是否>0，是的话初始化的Node[]大小为sizeCtl，否则为DEFAULT_CAPACITY（默认为16），创建这么一个Node[]，然后将table设为这个新建的Node[]
4. 最后将sizeCtl的值改为扩容阈值(现在新的table大小的0.75倍)

**put操作（自旋+CAS+synchronized）：**

```java
public V put(K key, V value) {
    return putVal(key, value, false);
}

/** Implementation for put and putIfAbsent */
final V putVal(K key, V value, boolean onlyIfAbsent) {
    // key 和 value 不能为空
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node<K,V>[] tab = table;;) {
        // f = 目标位置元素
        Node<K,V> f; int n, i, fh;// fh 后面存放目标位置的元素 hash 值
        if (tab == null || (n = tab.length) == 0)
            // 数组桶为空，初始化数组桶（自旋+CAS)
            tab = initTable();
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            // 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出
            if (casTabAt(tab, i, null,new Node<K,V>(hash, key, value, null)))
                break;  // no lock when adding to empty bin
        }
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            // 使用 synchronized 加锁加入节点
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    // 说明是链表
                    if (fh >= 0) {
                        binCount = 1;
                        // 循环加入新的或者覆盖节点
                        for (Node<K,V> e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node<K,V> pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node<K,V>(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    else if (f instanceof TreeBin) {
                        // 红黑树
                        Node<K,V> p;
                        binCount = 2;
                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            if (binCount != 0) {
                if (binCount >= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount);
    return null;
}

```

1. 先检查key和value是否为null，只要任一个为null都抛出异常，<font color="red">注意key也不能为null</font>
2. 先通过`hash=spread(key.hashcode())`算出hash值（具体方法是hashcodede的高16位和低16位做按位异或运算的结果再和HASH_BITS，也就是int的最大值进行按位与运算）
3. 通过<font color="red">自旋</font>的方式放入数据，开始一个`for(Node<K,V>[] tab=table;;)`的循环，不断取得table，插入成功后break：
   1. 看tab是否为null或长度为0，是的话执行initTable()初始化，初始化完成后再继续下面的操作
   2. `(tab.length-1&hash)`取得下标，然后看tab对应位置的头节点Node f，如果f为null的话直接放到tab的对应位置即可，这里<font color="red">使用CAS，比较这个位置是否还为null，是的话放入新的Node，直接结束</font>
   3. 如果f.hash=-1的话表明现在在扩容，应该去帮助扩容，调用`tab=helpTransfer(tab,f);`
   4. 如果上面两种情况（f=null或f.hash=-1）都不满足，则真正进入<font color="red">synchronized(f)</font>代码块，将这个Node锁住，然后将节点放入数组连着的链表或红黑树中：
      - 如果是一个链表，则遍历该链表，如果遍历过程中有节点e满足e.hash=刚才算出的hash，且e.key和key相等的话，直接修改e的val为新值；如果遍历到最后还没找到key相同的结点的话则在末尾插入一个新Node
      - 如果是红黑树，则执行putTreeVal方法
   5. 插入成功后，会判断刚才遍历的链表或者红黑树的节点数目，如果<font color="red">大于8</font>，则进行树化（树化的方法里会判断数组长度是否<64,如果小于的话转为数组扩容）

**get操作（没有CAS或自旋或synchronized）：**

1. 先通过`hash=spread(key.hashcode())`算出hash值，`(tab.length-1&hash)`取得下标，然后获得table对应下标的头节点
2. 如果头结点就是想要的话，直接返回val
3. 如果头节点.hash<0，说明在扩容或是红黑树，调用find方法查找
4. 否则是一个链表，遍历链表查找

### 6.为什么ConcurrentHashMap的key和value都不能为null

避免在多线程环境下出现歧义

**value不能为null的原因：**

在get(key)的时候如果返回的是null，无法确认确实是不存在这个key，还是说存在这个key但是value为null，在多线程场景下这种不确定性会造成线程安全性问题。

Hashmap之所以能解决这个问题，是因为当返回的value是null的时候，可以通过<font color="red">containsKey(key)</font>来判断是否真的有这个key，但是ConcurrentHashMap在多线程场景下这种方法是行不通的。例如：当有AB两个线程，这时候ConcurrentHashMap中不存在key1，线程A调用get(key1)返回了null，然后调用containsKey(key1)来判断是不是真的没有这个key1，这时候期望返回是false，但线程B在A调用get(key1)之后、containsKey(key1)之前，put了一个(key1,null)，那么这时候A调用的containsKey(key1)返回的就是true了，和预期不符了，也就是出现了二义性。

**key不能为null的原因：**

当“key=null"时，无法区分是“没有key”还是”有一个值为null的key“，在多线程场景下也会造成线程安全问题。

另外，当初concurrenthashmap的诞生就是为了解决hashtable的性能问题，hashtable不允许key或value为null，因此concurrentHashmap也延续了这一特点。

### 6.Hashtable是如何保证线程安全的

Hashtable的几乎每个实例方法前面都加了synchronized，锁住的是这个Hashtable对象，导致并发性很差

![image-20230820105345362](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230820105345362.png)

### 7.ArrayList底层数据结构、初始化、扩容操作

ArrayList继承AbstractList，实现List、RandomAccess(支持快速随机访问)、Cloneable(具有拷贝能力)、java.io.Serializable(可进行序列化操作，可以将对象转换为字节流进行持久化存储或网络传输)

<font color="red">底层数据结构：Object[] elementData</font>

可以存null，但不建议

**初始化操作：**

三种构造函数：

- 无参构造函数：令elementData为一个空数组，后面添加第一个元素了再扩容（第一次扩容为10）
- 传入初始容量的构造函数：令elementData为传入容量大小的数组
- 传入一个Collection参数，把这个Collection转为ArrayList

**添加元素、扩容操作：**

- 当调用add方法添加元素时，在放入元素之前，先执行以下操作：
  - <font color="red">先判断现在的数组是否还能放进一个新元素</font>，如果不能的话执行扩容操作：
    - <font color="red">当原数组长度为0，第一次扩容时，扩容为10</font>
    - 当不是第一次扩容时，扩容为新容量newCapacity=oldCapacity+(oldCapacity>>1)，然后检查newCapacity是否≥最小需要容量（也就是够放新元素），如果还是不够的话那将newCapacity重新赋值为最小需要容量。
    - 如果newCapacity大于 MAX_ARRAY_SIZE(Integer.MAX_VALUE-8)，执行 `hugeCapacity()` 方法来比较最小需要容量和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则newCapacity重新赋值为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE
    - 最后调用`elementData = Arrays.copyOf(elementData, newCapacity);`申请一个大小为newCapacity的新数组，然后把原数组内容拷贝过去，然后令原数组=这个新数组
  - 执行完扩容之后，将新值放入目标位置，size++

- 如果现在的容量还能放进新元素，那直接在末尾添加一个新元素即可

### 8.ArrayList和LinkedList的相同处和不同处

**相同处：**

- 都线程不安全
- 都实现了List接口

**不同处：**

- 底层数据结构：ArrayList底层数据结构是Object数组；LinkedList底层数据结构是Node的双向链表，每个Node都存了前驱和后继Node

- 集合特性：ArrayList实现了List，LinkedList实现了List、Deque，具有双端队列的特性，可以从两端插入和删除元素

- 添加/删除元素的时间复杂度：ArrayList在最后面添加/删除元素的时候，时间复杂度为<font color="red">O(1)</font>，如果在指定某个中间位置添加/删除元素，时间复杂度为<font color="red">O(N)</font>；LinkedList用链表存储，在头尾添加或删除元素的时间复杂度为<font color="red">O(1)</font>，在指定某个中间位置添加/删除元素时间复杂度也是<font color="red">O(N)</font>

- 关于快速随机访问：ArrayList实现了RandomAccess接口，支持快速随机按索引访问；LinkedList没实现这个接口，不支持快速随机访问，get(index)方法是以遍历的方式遍历到那个节点

- 关于内存浪费：ArrayList的空间浪费体现在数组的结尾会留一定的容量空间；LinkedList的空间浪费体现在它的每个节点都要存前驱和后继


### 9.集合转数组/数组转集合

**集合转数组**

写法：T[]数组=原链表.toArray(new T[0])

```java
List<String> list=new ArrayList<>();
list.add("A");
list.add("B");
String[] array=list.toArray(new String[0]);
```

几点注意：

- 必须是非基本数据类型的（其实List本来就有这个要求）
- toArray()里面<font color="red">没有传入任何参数的话返回的是Object类型的数组，所以必须要传入一个参数说明返回的类型，且初始长度为0</font>，0是为了节省空间，传list.size()也可以

**数组转集合**

写法1：链表=new ArrayList<>(Arrays.asList(原数组))

```java
String[] sgArray=new String[]{"A","B"};
List<String> sgList2=new ArrayList<>(Arrays.asList(sgArray));
```

- 注意直接用Arrays.asList(数组)是能够构建一个List的，但后续这个List不能进行add remove等操作，<font color="red">因为Arrays.asList返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类</font>，没有add、remove等方法

写法2——jdk8之后可以用stream：

链表=Arrays.stream(原数组).collect(Collectors.toList())

```java
String[] sgArray=new String[]{"A","B"};
List<String> sgList=Arrays.stream(sgArray).collect(Collectors.toList());

//基本数据类型利用stream的boxed也可实现：
int[] ints=new int[]{1,2,3};
List<Integer> intList=Arrays.stream(ints).boxed().
    					collect(Collectors.toList());
```

注意基本数据类型的数组加上boxed()之后也能转为对应包装类型的集合

### 10.PriorityQueue

优先队列，默认是小顶堆

特点：

- 每次调用add或offer添加一个元素e，都会调用<font color="red">siftUp</font>方法，调整为新的小顶堆。具体是假设这个数要添加进来的话下一个坐标是k，那么逐个看k的父节点坐标<font color="red">**parent=(k-1)/2**</font>，看这个数是否大于e，是的话把父节点元素移到k位置，然后k=parent，再看下一个parent……直到那个parent不再比e大，再把新元素e放到k位置

  ```java
  //注意：这里只是写个示意，不是完全一模一样的代码
  //k是这个元素要添加进来的下一个坐标，e是要添加的这个新元素
  public void siftUp(int k,E e){
      while(k>0){
          int parent=(k-1)>>>1;
          T p=queue[parent];
          if(p.compareTo(e)<=0){
              break;
          }
          queue[k]=p;
          k=parent;
      }
      queue[k]=e;
  }
  ```

- 每次调用remove或peek删除一个元素，返回下标为0的那个元素，然后将最后一个元素设为null，然后会调用<font color="red">siftDown</font>方法，将剩下的后面的元素调整为新的小顶堆。具体其实就是找到放原来最后一个元素e的新位置，从下标为0的根节点看起，找到它的左右子节点中最小的那个，然后把这个最小的节点和e比较，如果比e大，那么根节点是e的新位置，结束，否则把这个最小的子节点移到根节点，再以这个子节点的下标为根，又看它的两个子节点……

  ```java
  //注意：这里只是写个示意，不是完全一模一样的代码
  //k传入的值为0，e是之前最后面的那个元素
  public void siftUp(int k,E e){
      int half=size>>>1;
      //size为删除头元素后这个数组的元素个数,half是这么多个元素最后的那个非叶子节点的下标
      while(k<half){
          int child=(k<<1)+1;//左孩子下标
          Object c=queue[child];//左孩子
          int right=child+1;//右孩子下标
          if(right<size&&queue[right].compareTo(c)<0){
              child=right;
              c=queue[right];
          }
          if(e.compareTo(c)<=0){
              break;
          }
          queue[k]=c;
          k=child;
      }
      queue[k]=e;
  }
  ```

  

### 11.Collections.sort和Arrays.sort

java集合内置了Collections.sort和Arrays.sort，Collections.sort用于给List接口的实现类对象排序，Arrays.sort用于给数组排序。

Collections.sort首先会调用List.sort方法，在该方法内部，把这个list对象转为一个Object数组，然后调用Arrays.sort方法。

在java7以前的Arrays.sort，长度小于7的使用插入排序，大于等于7的使用归并排序；java7及其之后的，长度小于7的使用二分插入排序，大于7的使用优化的归并排序（Timsort，规则是首先看数组中有没有升序或降序的有序部分，称为runs，如果有降序部分的话，将其反转成升序，然后用二分插入排序排这些runs，最后用归并排序合并这些runs，另外在排序过程中，用一个栈维护每个run的大小，如果太小了就合并为符合规定的大小）

在Arrays.sort方法内部，会先看传入的参数是否含Comparator比较器，如果有的话



## 并发/线程

### 1、如何开启一个新线程

**分为两类：通过Thread对象的start()来开启一个指定任务的线程、通过线程池开启未事先指定任务的线程**

#### 通过Thread对象的start()来开启指定任务的线程

方法1：继承Thread类，重写run方法，然后直接实例化该类的一个对象a，调用a.start()

方法2：实现Runnable接口，重写run方法，实例化该类的一个对象a后作为参数构建一个Thread对象：Thread thread=new Thread(a)，然后thread.start()

方法3：实现Callable接口，重写call方法，实例化该类的一个对象a后，将对象a作为参数构建一个FutureTask f=new FutureTask(a)，然后将这个FutureTask对象作为参数构建一个Thread对象（FutureTask本来就实现了Runnable接口）：Thread thread=new Thread(f)，然后thread.start()

注意：不能直接调用thread.run()，new一个Thread然后调用该对象的start()，就会启动该线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，<font color="red">直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作</font>。

**总结： 调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。**

#### 通过线程池ExecutorService开启线程

创建ExecutorService（直接用Executors下面内置的或者ThreadPoolExecutor自定义的）的对象executor，然后:

- executor.execute(Runnable runnable)或
- executor.submit(Runnable runnable)或
- executor.submit(Callable callable)

<font color="orange">上面传进一个Runnable对象的其实可以改成用lambda表达式<font color="red">**()->{     }**</font></font>

### 2.Runnable和Callable的区别

表示的都是<font color="red">执行任务</font>的意思

- Runnable中定义了<font color="red">无返回值的run方法</font>，Callable中定义了<font color="red">有返回值的call方法</font>，所以如果需要执行的返回值，则要用Callable

- Runnable的run方法<font color="Red">不会抛出任何检查型异常</font>，有异常的话只能在run方法里面解决；Callable的call()方法<font color="red">可以抛出异常</font>

- Runnable对象<font color="Red">可以直接作为参数构造一个Thread对象</font>，Callable对象必须要先作为参数构造一个<font color="Red">FutureTask对象</font>，然后这个FutureTask对象作为参数去构造Thread对象

- 在线程池中可以execute(Runnable)和submit(Runnable)，但只能submit(Callable)，不能execute(Callable)

  【其实用Runnable对象也可以构造FutureTask对象，不过底层也是将这个Runnable对象转为了Callable（实际上是Callable的实现类RunnableAdapter），不过这里需要注意的是还需要传递一个result作为新构造的RunnableAdapter对象的call方法的返回值，当调用这个RunnableAdapter的call方法时，其实调用的是Runnable的run方法，因为这个run方法本来是没有返回值的，所以就把之前的result原封不动的返回（因此可见此返回值很假，你传入什么它就返回什么）】

### 3.Future接口及其实现类FutureTask

Future接口及其实现类可以用于获得任务返回结果、取消任务、判断任务是否已取消、判断任务是否已完成。

- boolean <font color="red">cancel</font>(boolean mayInterruptIfRunning)   取消任务
- boolean <font color="red">isCancelled()</font>   判断任务是否取消
- boolean <font color="red">isDone()</font>   判断任务是否执行完成
- V <font color="red">get()</font> throws InterruptedException, ExecutionException   获取任务执行结果，如果还没获取到会一直等在那里
- V <font color="red">get(long timeout, TimeUnit unit)</font> throws InterruptedException, ExecutionException, TimeoutException   指定时间内没有返回计算结果就抛出TimeOutException异常

FutureTask是Future的实现类，可以通过FutureTask包装Callable或Runnable然后开启线程，线程池对象submit()之后会返回一个FutureTask对象，调用这个FutureTask对象的get方法可以得到执行的结果

### 2.synchronized和volatile的区别

- synchronized可保证原子性、可见性、有序性：
  - 原子性：因为加了锁
  - 可见性：monitorenter相当于volatile的内存屏障
- volatile只能保证可见性（load、store内存屏障）和有序性（loadload、loadstore、storeload、storestore内存屏障），无法保证原子性（没有加锁）
- synchronized可修饰静态方法、实例方法、代码块；volatile一般用来修饰变量，不能修饰方法

#### volatile

- 保证可见性：通过内存屏障保证可见性。对volatile变量执行读操作时，会在读操作前加入一条load屏障指令，保证volatile变量每次读取数据的时候都强制从主内存读取；对volatile变量执行写操作时，会在写操作后加入一条store屏障指令，保证每次volatile修改之后强制将数据刷新会主内存。
- 保证有序性：对volatile变量进行操作时使用的内存屏障指令（LoadLoad屏障、StoreStore屏障、LoadStore屏障、StoreLoad屏障）能够禁止重排序。
- 不能保障原子性，可以用synchronized和ReentrantLock

#### synchronized

可保证可见性、有序性（前两个都是因为synchronized在获取锁时会使用monitorEnter指令，释放锁时使用monitorExit指令，这两个指令作用类似于volatile的内存屏障）、原子性

**使用**

- 修饰类中的某个方法——锁当前对象实例

  ```java
  synchronized void method() {
      //业务代码
  }
  ```

- 修饰类中的静态方法——锁这个类

  ```java
  synchronized static void method() {
      //业务代码
  }
  ```

- 修饰代码块——锁指定对象/类

  ```
  synchronized(object) 表示进入同步代码库前要获得 给定对象的锁。
  synchronized(类.class) 表示进入同步代码前要获得 给定 Class 的锁
  ```

**实现机制**

- 修饰语句块的时候：通过monitorEnter、monitorExit、锁计数器
- 修饰方法的时候：并没有 monitorenter 指令和 monitorexit指令，取得代之的是 ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法。JVM 通过该 `ACC_SYNCHRONIZED` 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用

但以上两种的本质都是<font color="red">对象监视器monitor的获取，获取的是实例对象或者.class对象的对象监视器</font>

### 3.synchronized和ReentrantLock的联系和区别

- 联系：两个都是<font color="red">可重入锁</font>，线程可以再次获取自己的内部锁，比如一个线程获得了某个对象的锁，此时还未释放，可以再次获取这个对象的锁

- 区别：
  - synchronized是一个<font color="red">关键字</font>，可以修饰静态方法、实例方法、代码块；ReentrantLock是一个<font color="red">类</font>，使用方法是声明一个ReentrantLock对象，然后调用这个对象的lock或unlock方法
  - synchronized是非公平锁，ReentrantLock默认非公平，可以公平
  - ReentrantLock是<font color="red">可中断锁</font>，线程获得锁时可以用`lock.lockInterruptibly()`而不用lock.lock()，lockInterruptibly()当未获得锁时会抛出一个InterruptedException，可以通过捕获到这个InterruptedException然后让这个线程继续做别的操作，不用一直等在那里。synchronized是不可中断的，只要未获得对象监视器使用权那就会一直等在那里
  - ReentrantLock可实现<font color="red">选择性通知</font>：可通过lock.newCondition创建若干个<font color="red">Condition（等待队列）</font>，调用condition.await()将不同的线程放入不同的Condition，通过condition.signal/signalAll唤醒不同Condition里的线程，synchronized做不到，只能用传统的wait/notify/notifyAll



### 2、synchronized的实现机制

本质上都是对象监视器monitor（实例对象或.class对象）的获取与释放，修饰代码块的情况是使用monitorenter和monitorexit来获取和释放实例对象监视器，修饰方法是通过<font color="red">flags</font>里的<font color="red">ACC_SYNCHRONIZED</font>标识，表明这是一个同步方法，获取和释放实例对象/.class对象的对象监视器

- 使用synchronized同步语句块的情况

  ```java
  public class SynchronizedDemo {
      public void method() {
          synchronized (this) {
              System.out.println("synchronized 代码块");
          }
      }
  }
  ```

  字节码如下，可以看到在同步代码块开始和结束位置分别有monitorenter和monitorexit，当执行monitorenter时，获取**对象监视器monitor**的持有权，并尝试获取**对象的锁**，如果**锁计数器**为0则表示该锁可以获取，获取后将锁计数器+1，执行代码块中的内容，否则获取失败，该线程要一直阻塞等待直到该锁被另一线程释放；获取锁后执行完代码块中的内容后（或者抛出异常时）执行monitorexit指令，判断自己是否为锁的拥有者，是的话将锁计数器-1，释放锁成功，否则释放锁失败。

  ![](https://oss.javaguide.cn/github/javaguide/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86.png)

- 使用synchronized修饰方法的情况（包括修饰实例方法和类静态方法两种）

  ```java
  public class SynchronizedDemo2 {
      public synchronized void method() {
          System.out.println("synchronized 方法");
      }
  }
  ```

  ![](https://oss.javaguide.cn/github/javaguide/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%862.png)

  字节码中没有monitorenter和monitorexit，取而代之的是<font color="red">flags</font>里的<font color="red">ACC_SYNCHRONIZED</font>标识，表明这是一个同步方法。

### 3、synchronized的锁升级机制

- JDK6之前synchronized是重量级锁，虽然安全但效率比较低，JDK6之后进行优化，有了锁的四种状态：<font color="red">**无锁状态→偏向锁状态→轻量级锁状态→重量级锁状态**</font>
- 随着竞争激烈而逐渐升级
- 只可升级，不可降级
- 这种策略是为了提高获得锁和释放锁的效率

**无锁状态**

特点：没有对资源进行锁定，<font color="red">所有线程都能访问并修改同一个资源，但同时只有一个线程能修改成功</font>。

修改操作在循环内进行，线程不断尝试修改资源，如果没有冲突就修改成功，否则不断循环尝试。

**偏向锁**

获得条件：当一个线程访问一段无锁的同步代码，且不存在竞争时，那么<font color="red">该线程在后续访问时便会自动获得锁</font>，从而降低获取锁带来的消耗，即提高性能。

特点：其他线程来的时候先检查对象头中的Mark Word，如果看到这一段同步代码被加了偏向锁，那么先判断偏向锁对应的那个线程是否还在<font color="red">（偏向锁不会主动释放，哪怕那个线程已经不在了）</font>，如果不在了那直接把Mark Word里的线程ID改为自己<font color="red">（自己获得了这个偏向锁）</font>；如果还在的话先暂停那个线程，这一步在全局安全点进行，然后设置Mark Word的标记位和指针，将它升级为<font color="red">轻量级锁</font>，然后之前拥有轻量级锁的那个线程继续运行，这个线程自旋。

内部机制：对比Mark Word

**轻量级锁**

获得条件：轻量级锁是指当锁是<font color="red">偏向锁</font>的时候，却<font color="red">被另外的线程所访问</font>，此时偏向锁就会升级为轻量级锁

特点：其他线程会通过<font color="red">**自旋**（不释放CPU，而是等待一段时间看看这段时间内资源是否会被释放，这个自旋的过程会用到**CAS**，也就是不断尝试将Mark Word中的轻量级锁对应的指向栈中锁记录的指针进行修改，修改成功了那就是获取轻量级锁成功了）</font>的形式尝试获取锁，线程<font color="red">不会阻塞</font>，从而提高性能。

内部机制：CAS+自旋

**重量级锁**

获得条件（二选一）：

- 当前是轻量级锁，且只有一个等待线程，但该线程自旋超过了一定次数
- 当前是轻量级锁，另一个线程在自旋，此时又来了第三个线程

特点：当有一个线程获取锁之后，<font color="red">其余所有等待获取该锁的线程都会处于阻塞状态</font>

内部机制：重量级锁就是传统的synchronized，通过monitor实现

### 4.ThreadLocal使用、原理

作用：让线程独立保存一份自己的变量副本，假如有一个线程不安全的对象A，每个线程都可以复制一份A的副本到自己的ThreadLocal里，直接操作通过这个ThreadLocal操作A的副本，就不会受到其他线程的影响

例子：

1. 当每个线程需要对一个共享成员变量A a拥有各自独立的副本时，可以将A用一个ThreadLocal来进行封装，然后直接将这个ThreadLocal<A>对象作为线程的成员变量

```java
/**
* User类，其中的属性id值为0
**/
public class User {
    public int id=0;
}

/**
*自定义线程类
**/
public class ThreadLocalExample extends Thread{

    // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本
    private  ThreadLocal<User> user1;
    private  User user2;

    public ThreadLocalExample(ThreadLocal<User> u1,User u2){
        user1=u1;
        user2=u2;
    }

    @Override
    public void run() {
        try {
            Thread.sleep(new Random().nextInt(1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        user1.get().id++;
        user2.id++;

        System.out.println("Thread Name= "+Thread.currentThread().getName()+" user1 = "+user1.get().id);
        System.out.println("Thread Name= "+Thread.currentThread().getName()+" user2 = "+user2.id);
    }

}

/**
*测试类
**/
public class Test {
    public static void main(String[] args) throws InterruptedException {
        ThreadLocalExample obj = new ThreadLocalExample(ThreadLocal.withInitial(()->new User()),new User());
        for(int i=0 ; i<3; i++){
            Thread t = new Thread(obj, ""+i);
            Thread.sleep(new Random().nextInt(1000));
            t.start();
        }
    }
}

========最终输出=========
Thread Name= 0 user1 = 1
Thread Name= 0 user2 = 1
Thread Name= 1 user1 = 1
Thread Name= 1 user2 = 2
Thread Name= 2 user1 = 1
Thread Name= 2 user2 = 3
```

2. 当每个线程都有一个共享引用成员变量A时，如果想让A中的某些成员变量B b对于每个线程都是独立的，那么就可以把这个成员变量用一个ThreadLocal来进行封装。

```java
/**
*下面这个类，id1用了ThreadLocal进行封装,id2没用，那么当多个线程同时操作同一个ObjectWithThreadLocal对象时，id1每个线程都有一份独立的变量副本，id2不是，就是普通共享的
**/
public class ObjectWithThreadLocal {
    private static ThreadLocal<Integer> id1=ThreadLocal.withInitial(()->0);//赋予初始值为1
    private int id2=0;
    public int getNextId1(){
        id1.set(id1.get()+1);
        return id1.get();
    }
    public int getNextId2(){
        id2++;
        return id2;
    }
}
/**
*自定义线程类
**/
public class MyThread extends Thread{
    private ObjectWithThreadLocal objectWithThreadLocal;
    public MyThread(ObjectWithThreadLocal o,String name){
        objectWithThreadLocal=o;
        setName(name);
    }
    @Override
    public void run() {
        try{
            Thread.sleep(new Random().nextInt(1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName()+" id1: "+objectWithThreadLocal.getNextId1());
        System.out.println(Thread.currentThread().getName()+" id2: "+objectWithThreadLocal.getNextId2());
    }
}

/**
*测试类
**/
public class Test {
    public static void main(String[] args) throws InterruptedException {
        ObjectWithThreadLocal objectWithThreadLocal=new ObjectWithThreadLocal();
        for(int i=0;i<3;i++){
            MyThread t=new MyThread(objectWithThreadLocal,""+i);
            Thread.sleep(new Random().nextInt(1000));
            t.start();
        }
    }
}


=============输出结果===========
0 id1: 1
0 id2: 1
1 id1: 1
1 id2: 2
2 id1: 1
2 id2: 3
```

一个注意的：使得ThreadLocal正确发挥作用的关键——<font color="red">每个线程操作的是同一个ThreadLocal对象</font>，而非 "不同的ThreadLocal里面用同一个对象进行初始化，然后用get得到这个对象再对这个对象进行操作" ←这样是不对的！

原理：每个Thread都有一个ThreadLocalMap，存这个线程的所有ThreadLocal，这个ThreadLocalMap类似于HashMap，以键值对的方式来存，key是每一个ThreadLocal，value是对应的值

- ThreadLocal的set方法：

  调用某个threadLocal.set(xx)方法时，先通过Thread t=ThreadcurrentThread()得到当前线程，然后ThreadLocalMap map = getMap(t);得到这个线程的ThreadLocalMap，然后把键值对<threadLocal,xxx>放进去

  ```java
  public void set(T value) {
      //获取当前请求的线程
      Thread t = Thread.currentThread();
      //取出 Thread 类内部的 threadLocals 变量(哈希表结构)
      ThreadLocalMap map = getMap(t);
      if (map != null)
          // 将需要存储的值放入到这个哈希表中
          map.set(this, value);
      else
          createMap(t, value);
  }
  ThreadLocalMap getMap(Thread t) {
      return t.threadLocals;
  }
  
  ```

- ThreadLocal的get方法：

  调用某个threadLocal.set(xx)方法时，先通过Thread t=ThreadcurrentThread()得到当前线程，然后ThreadLocalMap map = getMap(t);得到这个线程的ThreadLocalMap，然后调用这个ThreadLocalMap的get(threadLocal)获得对应的值

### 5.ThreadLocal的内存泄漏问题

`ThreadLocalMap` 中使用的 key 为 `ThreadLocal` 的<font color="red">弱引用</font>，而 value 为<font color="red">强引用</font>。所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。所以可能出现key为null的键值对，<font color="red">这个键值对因为value没有被回收所以也不会被回收，但因为key已经为null了所以实际上这个键值对不会再被用到了，这时候就可能产生内存泄漏</font>

`ThreadLocalMap` 实现中已经考虑了这种情况，在调用 `set()`、`get()`、`remove()` 方法的时候，会清理掉 key 为 null 的记录。为了确保安全，在不再使用某个 `ThreadLocal`后最好也手动调用这个ThreadLocal的`remove()`方法，让它为key的键值对在ThreadLocalMap里消失





### 4、线程池ThreadPoolExecutor

#### 线程池的几个关键参数及其意义

其实java线程池的实现原理很简单，说白了就是一个线程集合workerSet和一个阻塞队列workQueue。当用户向线程池提交一个任务(也就是线程)时，线程池会先将任务放入workQueue中。workerSet中的线程会不断的从workQueue中获取线程然后执行。当workQueue中没有任务的时候，worker就会阻塞，直到队列中有任务了就取出来继续执行

大致过程：

![图解线程池实现原理](https://oss.javaguide.cn/github/javaguide/java/concurrent/thread-pool-principle.png)

**参数：**

+ **int  corePoolSize:** 核心线程数，默认情况下核心线程创建了就不会被回收（可以设置allowCoreThreadTimeout=true，这样空闲核心线程超过存活时间也会被回收）
+ **int  maximumPoolSize:** 线程池最多能够有多少个线程线程(worker)在执行，当<font color="red">存放任务的阻塞队列workQueue满了,不能添加任务的时候，这个参数才会生效，</font>否则就算达到了核心线程数，只要阻塞队列没满，也不能创建新的线程
+ **long  keepAliveTime:** <font color="red">超出corePoolSize大小</font>的那些线程的生存时间，这些线程如果长时间没有执行任务并且超过了keepAliveTime设定的时间，就会消亡
+ **TimeUnit  unit: **生存时间对应的单位
+ **BlockingQueue<Runnable> workQueue:** 存放任务的阻塞队列
+ **ThreadFactory  threadFactory: **创建线程的工厂
+ **RejectedExecutionHandler  handler:** 当workQueue已经满了，<font color="red">并且线程池线程数已经达到maximumPoolSize</font>，将执行**拒绝策略**，否则还是可以一直创建新线程

#### java主要的四种内置线程池

**FixedThreadPool（固定线程数的线程池）**

- <font color="red">corePoolSize和maximumPoolSize均为自己传递的参数值nThreads</font>
- keepAliveTime为0，因为corePoolSize和maximumPoolSize相等，<font color="red">用不到keepAliveTime</font>
- 阻塞队列workQueue是<font color="red">LinkedBlockingQueue（无界队列，实际上也是有界的，大小默认值Integer.MAX_VALUE，也可以自定义大小，但FixedThreadPool用的是默认大小）</font>，永远不会放满
- 因为阻塞队列永远不会被放满，也就<font color="red">没有拒绝策略</font>

过程（线程池execute()方法逻辑）：任务到来时，如果当前线程数小于corePoolSize，那创建新线程执行它，否则任务进入无界队列，然后线程执行完手头的任务了就不断从无界队列中拿任务

缺点：阻塞队列永远放不满，永远不会拒绝任务，任务放得太多可能会OOM

**SingleThreadExecutor（只有一个线程的线程池）**

- 除了<font color="red">corePoolSize和maximumPoolSize均为1</font>外，别的参数和FixedThreadPool相同

过程：任务到来时，若当前无运行线程则创建一个线程，否则进入阻塞队列，然后这个单一线程执行完了手动任务就不断从阻塞队列拿新任务。

缺点：易OOM，且因为线程只有一个，相对来说并发性不高

**CacheThreadPool（会不断创建线程的线程池）**

- <font color="red">corePoolSize为0，maximumPoolSize为Integer.MAX_VALUE</font>
- keepAliveTime为60，时间单位为秒
- 阻塞队列是<font color="red">SynchronousQueue（不存储元素的阻塞队列）</font>
- 因为maximumPoolSize为Integer.MAX_VALUE，所以也<font color="red">没有拒绝策略</font>

过程：主线程不断执行SynchronousQueue.offer(Runnable task)向阻塞队列提交任务（FIFO），线程池中的空闲线程不断执行SynchronousQueue.poll从阻塞队列获取任务，如果一个offer和一个poll配对成功，则一个任务得到线程处理，否则要等在那里。如果一个任务来了且通过offer来到了阻塞队列，但初始没有线程，或者线程都不空闲时，创建新线程，然后这个新线程执行poll。

缺点：maximumPoolSize为Integer.MAX_VALUE，如果任务数量过多且执行速度较慢，可能会创建大量线程，容易OOM

**ScheduledThreadPool（在给定延迟后运行任务或定期执行任务）**

- <font color="red">corePoolSize为传入的参数，maximumPoolSize为Integer.MAX_VALUE</font>
- keepAliveTime为0
- 阻塞队列是，<font color="red">DelayedQueue（延迟阻塞队列）</font>，内部元素按照延迟的时间长短排序，执行时间越靠前的元素越排在前面，且<font color="red">元素满了之后自动扩容，所以队列永远不会满</font>，所以最多只能创建corePoolSize个线程

过程：任务到来后进入DelayedQueue，然后在队列中按执行时间的先后排序，到执行时间了，如果有空闲线程就执行，没有的话如果线程数未达到corePoolSize那就创建新线程执行，否则等着

缺点：DelayedQueue也是无界的，maximumPoolSize为Integer.MAX_VALUE，可能堆积大量请求造成OOM

#### 几种阻塞队列

其实是java中的**BlockingQueue接口**，该接口实现Queue接口

![](https://img-blog.csdnimg.cn/20200611175136657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzY5NTkxMQ==,size_16,color_FFFFFF,t_70)

BlockingQueue有以下七个实现类：

![](https://img-blog.csdnimg.cn/20200611175200766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzY5NTkxMQ==,size_16,color_FFFFFF,t_70)

![image-20230907105035768](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230907105035768.png)

- **ArrayBlockingQueue：由<font color="red">数组</font>实现的<font color="red">有界定长</font>队列**
  - 底层是一个<font color="red">定长Object[]数组，初始化时要传入数组的长度，不能扩容</font>
  - 任务按照先进先出的顺序
  - 生产者放任务和消费者拿任务用的是<font color="red">同一把锁</font>（ReentrantLock，放/拿数据时lock.lock()、lock.unLock()），<font color="red">生产者和消费者之间无法并行</font>
  - 默认使用的ReentrantLock非公平，可以设为公平

- **LinkedBlockingQueue：由<font color="red">链表</font>实现的<font color="red">无界</font>队列**
   -  底层是<font color="red">Node节点组成的单向链表</font>
   -  实际上是有界的，默认值大小为Integer.MAX_VALUE，接近21亿，可以看做无界了。<font color="red">在自定义线程池的时候，阻塞队列一般使用LinkedBlockingQueue</font>，只是需要指定容量为一个非Integer.MAX_VALUE的值
   -  生产者和消费者用的也都是ReentrantLock，但是不同的两把锁，<font color="red">生产者用的是putLock，消费者用的是takeLock，生产者和消费者之间可以并行</font>
   -  被使用在FixedThreadPool和SingleThreadExcutor中


- **SynchronousQueue：不存储元素，只是用于将任务从生产者传递给消费者**
  -  每一个添加元素的操作必须等待另一个线程获取元素的操作，否则不能继续添加元素。反之亦然
  -  目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。
  -  不使用可重入锁，内部用一个Transferer完成数据的转移，该Transferer用volatile修饰
  -  被使用在CacheThreadPool中

-  **DelayQueue：按<font color="red">任务执行时间先后排序</font>的<font color="red">无界（会自动扩容）</font>队列**
   -  底层用一个PriorityQueue实例存元素，默认容量11，<font color="red">满了之后自动扩容为oldCapacity+(oldCapacity>>2)</font>
   -  里面的元素要实现Delayed接口
   -  生产者和消费者共用同一把ReentrantLock
   -  被使用在SheduledThreadPool中

-  **PriorityBlockingQueue：支持<font color="red">优先级</font>的<font color="red">无界(会自动扩容）</font>队列**
   -  实际上是PriorityQueue的线程安全版本，但需要注意的是它不像DelayQueue那样用一个PriorityQueue成员实例来存，而是对PriorityQueue里面的各个方法进行了优化，加了ReentrantLock的相关操作
   -  和PriorityQueue一样，底层为一个<font color="red">Object[]数组实现的**小根堆（一种完全二叉树，每个节点都小于等于他的左右子节点）**</font>，默认容量为11，也可指定容量，<font color="red">满了之后自动扩容为oldCapacity+(oldCapacity>>1)</font>，类似于ArrayList
   -  放入的元素必须是可比较的，如果是自定义类要实现Comparable接口并重写compareTo，或者构造PriorityBlockingQueue时使用带比较器Comparator的构造函数，并重写compare方法
   -  生产者和消费者共用同一把ReentrantLock
   
-  **LinkedTransferQueue：相比LinkedBlockingQueue，多了transfer和tryTransfer方法**
   -  transfer方法：如果有正在等待接收元素的消费者，直接把这个元素给这个消费者，不放入队列；否则放入队列，然后直到有消费者消费了这个元素才返回
   -  tryTransfer方法：有带时间参数和不带时间参数两种类型，相比于transfer，就是如果此时没有等待接收元素的消费者，那么直接返回false（不带时间参数的）或者等待一段时间还没消费者消费就返回false（带时间参数的）
-  **LinkedBlockingDeque：相比LinkedBlockingQueue，可以在两端入队或出队，可运用在工作窃取模式下**

**总结**

|                       | 底层实现                                                     | 扩容                          | 锁                                                           |
| --------------------- | ------------------------------------------------------------ | ----------------------------- | ------------------------------------------------------------ |
| ArrayBlockingQueue    | Object[]                                                     | 否，定长                      | 共用ReenTrantLock                                            |
| LinkedBlockingQueue   | Node单向链表                                                 | 否，默认容量Integer.MAX_VALUE | 两把ReenTrantLock                                            |
| SynchronousQueue      | 不存储元素                                                   | 没有容量                      | 不用锁，<br>内部用一个Transferer完成数据的转移，该Transferer用volatile修饰 |
| DelayQueue            | PriorityQueue                                                | 默认容量11，满了扩容为1.5倍   | 共用ReenTrantLock                                            |
| PriorityBlockingQueue | Object[]实现的小根堆                                         | 默认容量11，满了扩容为1.5倍   | 共用ReenTrantLock                                            |
| LinkedTransferQueue   | 比起<br>LinkedBlockingQueue<br>多了transfer()和tryTransfer() |                               |                                                              |
| LinkedBlockingDeque   | 比起<br>LinkedBlockingQueue<br>，两端都能添加删除            |                               |                                                              |



#### 几种拒绝策略

所有拒绝策略都实现RejectedExecutionHandler接口，

并重写rejectedExecution(Runnable r, ThreadPoolExecutor executor)方法

![image-20230814001413177](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230814001413177.png)

几种jdk内置的（他们都是ThreadPoolExecutor的内部类）：

- ThreadPoolExecutor.AbortPolicy（默认）：直接丢弃任务并抛出RejectedExecutionException异常

- ThreadPoolExecutor.DiscardPolicy：也直接丢弃任务，但不会抛出异常

- ThreadPoolExecutor.DiscardOldestPolicy：会将阻塞队列最头部的任务删掉，然后再尝试将新任务入队

- ThreadPoolExecutor.CallerRunsPolicy：直接不等了，主线程自己调用那个Runnable任务的run()方法去执行该任务

#### 如何创建线程池

- 使用java的内置线程池——通过Executors创建ExecutorService

  ```java
  //创建FixedThreadPool
  private static void createFixedThreadPool() {
            ExecutorService executorService = Executors.newFixedThreadPool(3);
            for (int i = 0; i < 10; i++) {
                final int index = i;
                executorService.execute(() -> {
                    // 获取线程名称,默认格式:pool-1-thread-1
                    System.out.println(DateUtil.now() + " " + Thread.currentThread().getName() + " " + index);
                    // 等待2秒
                    sleep(2000);
               });
           }
       }
  //创建SingleThreadExcutor
  private static void createSingleThreadPool() {
           ExecutorService executorService = Executors.newSingleThreadExecutor();
           for (int i = 0; i < 10; i++) {
               final int index = i;
               executorService.execute(() -> {
                   // 获取线程名称,默认格式:pool-1-thread-1
                   System.out.println(DateUtil.now() + " " + Thread.currentThread().getName() + " " + index);
                   // 等待2秒
                   sleep(2000);
               });
           }
       }
  //创建CacheThreadPool
  private static void createCachedThreadPool() {
           ExecutorService executorService = Executors.newCachedThreadPool();
           for (int i = 0; i < 10; i++) {
               final int index = i;
               executorService.execute(() -> {
                   // 获取线程名称,默认格式:pool-1-thread-1
                   System.out.println(DateUtil.now() + " " + Thread.currentThread().getName() + " " + index);
                   // 等待2秒
                   sleep(2000);
               });
           }
       }
  //创建ScheduledThreadPool
  private static void createScheduledThreadPool() {
        ScheduledExecutorService executorService =Executors.newScheduledThreadPool(3);
        System.out.println(DateUtil.now() + " 提交任务");
        for (int i = 0; i < 10; i++) {
           final int index = i;
           executorService.schedule(() -> {
           // 获取线程名称,默认格式:pool-1-thread-1
           	System.out.println(DateUtil.now() + " " + Thread.currentThread().getName() + " " + index);
           	// 等待2秒
           	sleep(2000);
               }, 3, TimeUnit.SECONDS);
           }
       }
  ```

- 自定义线程池，也就是使用那七个参数——通过ThreadPoolExecutor创建ExecutorService

  ```java
  private static void createThreadPool() {
           ExecutorService executorService = new ThreadPoolExecutor(2, 10,
                   1, TimeUnit.MINUTES, new ArrayBlockingQueue<>(5, true),
                   Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());
           for (int i = 0; i < 10; i++) {
               final int index = i;
               executorService.execute(() -> {
                   // 获取线程名称,默认格式:pool-1-thread-1
                   System.out.println(DateUtil.now() + " " + Thread.currentThread().getName() + " " + index);
                   // 等待2秒
                   sleep(2000);
               });
           }
       }
  ```

#### 线程池中线程数目的设置

线程池中线程数量过大或过小都不合适，太小的话如果同一时间有的大量任务需要处理，可能会导致大量任务都在阻塞队列中等待，没有充分利用CPU资源；太大的话，因为CPU在任意时刻只能被一个线程使用，并且采用时间片轮转的形式，一个线程的CPU时间片用完了就要保存自己的状态，然后将CPU让出，待下次又轮到它使用CPU了再把状态切换回来，这就是一次**上下文切换**，上下文切换是需要时间的，当线程数目过多时，大量线程同时争取CPU资源，会导致大量的上下文切换，从而影响整体执行效率。

推荐的线程数目设置公式：

- **CPU密集型任务：CPU核心数+1**

  这种情况每个线程都需要长时间使用CPU，因此要尽可能降低上下文切换的时间，比CPU核心数多一个是为了防止如果某个线程因为种种原因暂停使得一个CPU空闲，那么多出来的那个线程就可以充分利用这个空闲的CPU

- **I/O密集型任务：2倍CPU核心数**

  这种情况线程大部分时间都在做I/O，不会占用CPU，CPU大部分时间空闲，因此可以多设置一些线程。

线程池的核心代码数目和最大代码数目是可以在运行阶段动态设置的，调用threadoolExecutor.setCorePoolSize、threadoolExecutor.setMaximunSize即可

#### 线程池动态调整参数

在实际项目中，可能会遇到某些任务较为耗时，这种情况下可以动态调整线程池的参数，这些任务执行完后再把参数调整回来

ThreadPoolExcutor中动态调整参数的API:

![image-20240326132355497](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240326132355497.png)

一个耗时任务中动态调整线程池参数的例子：

![image-20240326132513982](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240326132513982.png)

注意：

- 把corePoolSize调小时，多余的线程不会马上被删除，而是空闲了之后过了keepAliveTime才删除
- 当corePoolSize>maximumPoolSize时，最多也是只有maximumPoolSize个活跃线程



#### 线程池ExecutorService的几个方法对比

**execute() vs. submit()**

- execute只能提交Runnable，不能提交Callable，submit可以提交Runnable和Callable
- execute没有返回值，submit会返回一个Future对象f，通过f.get()可以得到返回值，如果任务是Runnable的话返回值是null，是Callable的话返回的是其call方法的返回值。

**shutdown() vs. shutdownNow()**

- shutdown：关闭线程池，线程池状态变为<font color="red">SHUTDOWN</font>，不再接受新任务，但是之前已经接受的任务必须执行完毕
- shutdownNow：关闭线程池，线程池的状态变为<font color="red">STOP</font>，不仅不再接受新任务，且终止当前正在执行的任务，停止处理排队的任务，返回正在等待执行的任务 List。

**isTerminated() vs. isShutdown()**

- 调用shutDown()之后isShutdown()返回true
- 调用shutDown()<u>且所有之前线程池里的任务完成</u>之后isTerminated()返回true

### 5.监控线程池运行状态

可通过Springboot的Actuator组件来监控

也可以通过ThreadPoolExecutor的相关API来进行监控，如线程池中当前线程数和活跃线程数、已执行完成的任务数、正在排队中的任务数等等，可以开启一个定时任务，每隔一段时间就通过这些API来获得线程池内的一些信息

### 5.线程的生命周期和状态

![](https://oss.javaguide.cn/github/javaguide/java/concurrent/640.png)

上图需要注意的：Thread.xxx()表示的可能是调用那个线程的xxx方法，例如threadA.start()就是调用threadA的start()方法，也可能是调用静态方法，例如Thread.sleep()，Object.xxx()表示调用某个资源对象的xxx方法，如lock.wait()表示此时让获取对象lock的那个线程释放锁和CPU，进入等待状态。

- **NEW**: 初始状态，线程被创建出来但没有被调用 `start()` 。
- **RUNNABLE**: 运行状态，线程被调用了 `start()`等待运行的状态。获得了CPU时间片资源后来到**RUNNING（运行中）**，时间片到或释放CPU则来到**READY（就绪）**(注意JVM角度只有runnable，没有running和ready)
- **BLOCKED** ：阻塞状态，需要等待锁释放。<font color="red">此时因拿不到锁而阻塞</font>
- **WAITING**：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。<font color="red">一般是拿到锁了但因为资源不足等原因进入等待（如果是通过wait进入等待则释放了锁，通过sleep进入则没有释放锁）</font>
- **TIME_WAITING**：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。
- **TERMINATED**：终止状态，表示该线程已经运行完毕。

### 6.线程死锁的四个必要条件和破除

**产生死锁的四个必要条件（只要发生死锁，这些条件必然成立，只要一个条件不成立那就不会发生死锁）：**

- **互斥条件：**该资源任意一个时刻只由一个线程占用。

- **请求与保持条件**：一个线程因请求资源而阻塞时，对已获得的资源保持不放。

- **不剥夺条件**：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。

- **循环等待条件**：若干线程之间形成一种头尾相接的循环等待资源关系。<font color="red">每一个线程所需要的资源被上一个线程占用着</font>

**预防死锁——破坏死锁产生的必要条件：**

- **破坏互斥条件：**将资源改造为可共享的资源（如SPOOLing技术）
- **破坏请求与保持条件** ：<font color="red">静态分配策略：</font>一次性申请完所有的资源再开始执行，这样就不会有等待资源且自己还持有其他资源的情况了。

- **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。

- **破坏循环等待条件** ：<font color="red">层次分配策略：</font>给系统中所有资源统一编号，规定线程必须按照从小到大的顺序申请资源，当<font color="red">拥有编号小的资源时才能申请编号大的资源，在释放了编号大的资源时才能释放编号小的资源</font>，且同类资源（即同一编号的资源）要一次性申请完。

**避免死锁：**

可以借助银行家算法等算法，得到申请资源的**安全序列**，每个线程都按这个安全序列申请资源，就可以进入**安全状态**

**检测死锁：**

操作系统中的每一刻时刻的**系统状态**都可以用**进程-资源分配图**来表示，用于**检测系统是否处于死锁状态**。

1. 如果进程-资源分配图中<font color="red">无环路</font>，则此时系统没有发生死锁

2. 如果进程-资源分配图中<font color="red">有环路</font><font color="red">，且每个资源类仅有一个资源</font>，则系统中已经发生了死锁。

3. 如果进程-资源分配图中<font color="red">有环路，且涉及到的资源类有多个资源</font>，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 **既不阻塞又非独立的进程** ，<font color="red">该进程能够在有限的时间内归还占有的资源</font>，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 **消除所有的边** ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 **拓扑排序**)

**死锁的解除方法：**

- <font color="red">结束所有进程</font>，重启操作系统
- <font color="red">一次性撤销</font>涉及死锁的所有进程，解除死锁后再重新运行这些进程
- <font color="red">逐个撤销</font>涉及死锁的进程，回收其资源直至死锁解除
- 抢占资源：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除

### 7.wait()和sleep(time)的区别

- wait()是Object类的本地方法，调用时用一个对象.wait()（这个对象是该线程占有的那个资源对象，释放的就是这个对象的对象锁）；sleep(time)是Thread类的静态本地方法，调用时直接Thread.sleep(time)
- <font color="red">wait()释放锁了，sleep()没有释放</font>
- sleep方法里面必须传递一个long参数，表示多少毫秒后线程自动苏醒。wait里面可以传递参数也可以不传递参数。不传递参数的`wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep(time)`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
- `wait()` 通常被用于线程间交互/通信，`sleep(time)`通常被用于暂停执行。

### 8.JVM内存结构和JMM的区别

- JVM内存结构定义了JVM运行时如何分区存储程序数据，比如说堆主要用来放对象实例

- JMM和并发编程有关，规定了要遵守的并发相关原则和规范，比如说

  - 共享变量要在主内存中初始化，当线程要操作一个共享变量之前必须把这个共享变量的值载入到工作内存中，然后修改了之后又存储回主内存(<font color="red">即为共享变量提供了可见性保障</font>)

  - 根据happens-before原则，<font color="red">允许不改变执行结果的重排序</font>

    综上，JMM规定了可见性，但没有规定有序性和原子性

### 9.AQS

AQS全称AbstractQueuedSynchronizer，即**抽象队列同步器**，是一个**抽象类**，用于构建锁和同步器，如ReentrantLock、ReentrantReadWriteLock、Semaphore、CountDownLatch、SynchronousQueue都是基于AQS构建的。

<font color="red">注意ReentrantLock、Semaphore这种不是AQS的实现类，是他们内部的成员才是AQS的实现类，例如ReentrantLock和Semaphore的内部类Sync，又有FairSync和NoFairSync两种</font>

> 例如ReentrantLock有一个成员变量为Sync类的对象sync，lock方法就是通过调用这个sync.lock()来实现的，抽象类Sync是ReentrantLock的一个内部类，继承了AbstractQueuedSynchronizer，Sync有两个具体实现子类NofairSync和FairSync，当调用sync.lock()时，因为这是一个抽象方法，实际调用的是两个子类的lock()，ReentrantLock的sync成员变量默认是NofairSync，如果构建这个ReentrantLock时传入的参数是true，那么才是FairSync

AQS实现线程阻塞和唤醒主要靠的就是LockSupport.park()和LockSupport.unpark()，LockSupport可以指定唤醒某个线程

**AQS底层机制**

AQS的实现类中的几个重要的部分：

- **管理同步状态的int state（用volatile修饰保证可见性）:**

  在不同的子类中这个state不同的值代表不同的涵义，例如在ReentrantLock中，state=0表示没有被加锁，=1表示已被加锁，>1表示被同一个线程加了多少次锁（用于ReentrankLock等可重入锁）；在共享锁Semaphore中，state的初始值代表共享数目，每获得一次锁那么state-1，直到减为0就不能再获得了

  - 有关state的方法有以下三种：
    - getState：获得这个state的值
    - setState：直接修改state值
    - compareAndSetState：通过CAS不断修改state的值

- **CLH锁——底层用Node双向链表实现：**

  当线程通过getState方法读取state的值>0，或者通过CAS获得锁失败后，会把这个线程包装为一个Node节点，这些Node利用prev和next两个指针构建双向链表，<font color="red">所有没获得锁的线程就是以这样的Node双向链表的形式，构成了一个等待队列</font>

  ![image-20230915004222881](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230915004222881.png)

​		当持有锁的线程释放锁后，<font color="red">会唤醒**第一个**Node，然后对应的线程继续尝试以CAS修改state，如果成功的话出队</font>

- **尝试获取/释放资源的一些方法：**

  对于独占锁（如ReenTrantLock、ReentrantReadWriteLock的写锁），实现tryAcquire、tryRelease即可，对于共享锁（如Semaphore、ReentrantReadWriteLock的读锁）实现tryAcquireShared、tryReleaseShared即可

  ```java
  //独占方式。尝试获取资源，成功则返回true，失败则返回false。
  protected boolean tryAcquire(int)
  //独占方式。尝试释放资源，成功则返回true，失败则返回false。
  protected boolean tryRelease(int)
  //共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
  protected int tryAcquireShared(int)
  //共享方式。尝试释放资源，成功则返回true，失败则返回false。
  protected boolean tryReleaseShared(int)
  //该线程是否正在独占资源。只有用到condition才需要去实现它。
  protected boolean isHeldExclusively()
  ```

  

### 10.公平锁和非公平锁

- 公平锁（FairSync）：按照线程申请资源的先后顺序获得锁，锁释放后唤醒下一个等待队列中最先申请这个资源的线程

  底层机制（以ReentrantLock的FairSync为例）：当调用reentrantLock.lock()时，会调用sync的<font color="red">tryAcquire方法</font>，先用getState判断当前是否为0，如果是的话<font color="red"><u>再判断当前是否有Node节点在等待且等待时间比当前线程长</u>，如果没有的话再尝试用CAS获得修改state的值</font>，如果获得锁失败那么会<font color="red">将当前线程包装为一个Node加入到链表末尾</font>，如果getState返回的结果不为0，那么会判断当前占有这个资源的线程是否是当前线程，如果是的话state+1，否则也将当前线程包装为Node加入链表末尾

- 非公平锁（NoFairSync）：并非按照线程申请资源的先后顺序获得锁，而是抢占式的，后来的线程如果抢到了资源就能获得，还有一些是按照线程优先级获得锁

  【缺点：可能会有线程一直获取不到资源而被饿死，可能的解决方案——当一个线程长时间等不到资源时从等待队列中释放该线程，可以先提高这个线程的优先级，然后再让这个线程去试着抢占资源】

  底层机制（以ReentrantLock的NoFairSync为例）：相比FairSync，tryAcquire方法中，当用getState判断当前state为0时，<font color="red"><u>不再判断多一步当前是否有Node节点在等</u>，而是直接就CAS，失败了再加到链表的末尾</font>

【概括来说：公平锁是指申请资源的线程可以按照申请的先后顺序获得锁，非公平锁指申请资源的线程不一定按照申请的先后顺序获得锁，虽然一般来说吞吐量高但可能出现饿死的状况。在底层机制方面，区别在于执行tryAcquire方法的时候，在CAS尝试获得锁之前，是否先判断当前是否还有Node节点在等待】

### 10.Semaphore（共享信号量）

共享锁，同时允许permits个线程持有锁

里面有一个AQS实现类成员实例Sync（实际是FairSync或NoFairSync），构造Semaphore时会传递一个参数int permits，作为Sync的state的初始值，当线程要获取一个锁时调用tryReleaseShared方法使state-1，state为0就不能再获取了，从而实现同时允许permits个线程持有锁。

### 11.CountDownLatch（倒计时器）

也是共享锁的一种，state初始值设为count，每调用一次countDown方法就使得state-1，state≤0后，之前调用了countDownLatch.await()处于等待状态的那些线程就会被唤醒。

应用场景：<font color="red">可用于某些线程必须等待其他n个线程执行完一些动作后再恢复执行</font>。首先实例化CountDownLatch countDownLatch=new CountDownLatch(n)，A、B线程一开始先调用countDownLatch.await()处于等待状态，其他线程执行完各自动作后调用countDownLatch.countDown()，等到n个线程都调用了这个方法后state减为0了，线程A、B就被唤醒继续执行了。

### 11.CyclicBarrier（循环栅栏）

也是共享锁的一种，作用是每count个线程进入栅栏后再统一释放这些线程，state初始值设为count，每有一个线程调用cyclicBarrier.await时，state-1，<font color="red">在state减为0前这些线程都处于等待，减为0后（也就是一共有count个线程调用await方法后），这些原本出于等待的线程全部被唤醒</font>，然后state又恢复为count，等待下一批count个线程……（循环）

### 11.CompletableFuture

Future在实际使用过程中存在局限性：

- 一定要通过get这个阻塞方法才能获得某个Future的执行结果，不能做到这个Future执行完毕后自动回调一个函数，这样就很难做到任务的自动编排

CompletableFuture的优势：

![](https://oss.javaguide.cn/github/javaguide/java/concurrent/completablefuture-class-diagram.jpg)

CompletableFuture实现了Future和CompletionStage接口，完全具有Future功能，同时还实现了CompletionStage接口：

- 提供了大量的回调函数，可以在任务运行完毕后自动回调，也可以把这个结果连接到一个新的CompletionStage，从而实现任务的自动编排，实现链式任务流

  (注意，<font color="red">CompletableFuture的get方法也是阻塞的，重点在于回调函数实现自动编排</font>)

#### 创建执行异步任务的线程

<font color="red">如果是单核CPU，则异步任务之间是并发执行，如果是多核CPU或多CPU，则异步任务之间是并行执行</font>

**runAsync方法**

- 用来创建一个<font color="red">不需要返回结果</font>的任务，底层也是通过开启一个线程实现的
- CompletableFuture的静态方法
- 接收一个Runnable对象（或者用lambda表达式也可以），返回一个CompletableFuture\<Void>对象，所以这个任务没有返回值
- 会创建一个新线程，默认是使用默认的线程池ForkJoinPool.commonPool来获取线程，如果使用下面的第二种构造函数传进一个线程池的话是用这个线程池来获取线程

```java
static CompletableFuture<void> runAsync(Runnable runnable)
static CompletableFuture<void> runAsync(Runnable runnable,
                                        Executor executor)
```

**supplyAsync方法**

- 用来创建<font color="red">有返回结果</font>的任务
- CompletableFuture的静态方法
- 接受一个Supplier<U>接口的实现类对象，该实现类的get方法返回一个U类对象
- 返回一个CompletableFuture\<U>对象
- 会创建一个新线程，默认是使用默认的线程池ForkJoinPool.commonPool来获取线程，如果使用下面的第二种构造函数传进一个线程池的话是用这个线程池来获取线程

```java
static CompletableFuture<U> supplyAsync(Supplier<U> supplier)
static CompletableFuture<U> supplyAsync(Supplier<U> supplier,
                                       Executor executor)
```

#### 异步任务回调

**thenApply方法**

- 用来自动回调一个函数然后得到下一个<font color="red">有返回值的</font>CompletableFuture

之前已经用supplyAsync创建一个CompletableFuture<U> cf1了，那么接下来可以调用cf.thenApply(Function<U,T>)，得到一个新的CompletableFuture<T>对象cf2，当cf执行完本线程的任务之后，自动就会调用回调函数Function<U,T>，得到这个新的CompletableFuture<T>对象cf2

```java
CompletableFuture<T> thenApply(Function<U,T> f);
```

主线程可以用cf2.get()获取最后得到的这个结果

把thenApply直接写在第一个cf的实例化函数后面也可以，只需要把cf改成CompletableFuture<T>的就可以

**thenAccept方法**

- 用来自动回调下一个函数，但不需要返回值（也就是返回一个CompletableFuture<Void>）
- 参数是一个Consumer<T>，可以接受一个T类型的上一阶段任务执行的结果，对其进行消费使用

```java
CompletableFuture<Void> thenAccept(Consumer<T> action);
```

**thenRun方法**

- 用来自动回调执行下一个任务
- 接收的参数是一个Runnable，而不是上一阶段的执行结果

```java
CompletableFuture<Void> thenRun(Runnable action);
```

<font color="orange">thenRun和thenAccept一样都是没有返回值的，区别在于前者没有接收上一步得到的结果，后者接收了，所以后者可以对这个结果进行一些操作，前者不能</font>

**thenxxxAsync方法**

一般情况下，前面的三个方法的<font color="red">回调任务和之前阶段的任务使用的是<u>同一线程</u>完成</font>

thenxxxAsync方法会<font color="red"><u>在单独的线程中</u>异步执行所有回调函数，进一步提高并行度</font>

thenApplyAsync、thenAcceptAsync、thenRunAsync

```java
CompletableFuture<T> thenApplyAsync(Function<U,T> f);
CompletableFuture<T> thenApplyAsync(Function<U,T> f,
                                   Executor e);
CompletableFuture<Void> thenAcceptAsync(Consumer<T> action);
CompletableFuture<Void> thenAcceptAsync(Consumer<T> action,
                                       Executor e);
CompletableFuture<Void> thenRunAsync(Runnable action);
CompletableFuture<Void> thenRunAsync(Runnable action,
                                    Executor e);
```

#### 异步任务组合

**thenCompose**

- 能够组合<font color="red">**两个**有依赖关系的</font>CompletableFuture，得到一个CompletableFuture
- 用来连接两个<font color="red">有依赖关系的CompletableFuture</font>，假设有两个CompletableFuture，第一个是CompletableFuture<T> c1，第二个是CompletableFuture<R> c2，c2需要依赖c1的结果，使用c1.thenCompose方法并将c2作为参数传递进去，最终能获得一个新的组合任务CompletableFuture<R> c3
- 编排的两个CompletableFuture也有可能在不同的线程执行

```java
CompletableFuture<R> thenCompose(Function<T,CompletableFuture<R>> f)
```

**thenCompose**

- 组合<font color="red">**两个**无依赖关系的</font>CompletableFuture
- 假设有两个CompletableFuture，第一个是CompletableFuture<T> c1，第二个是CompletableFuture<R> c2，他们之间无依赖关系，使用c1.thenCombine方法并将c2以及<font color="red">一个组合两个CF的结果的函数b</font>作为参数传递进去，最终能获得一个新的组合任务CompletableFuture<V> c3，当两个CF都执行完后，会自动执行这个函数b，对两个CF的结果进行处理，并将结果V返回

```java
//T是第一个任务的结果，U是第二个任务的结果，V是经过BiFunction应用转换后的结果
CompletableFuture<V> thenCombine(CompletableFuture<R> c2, BiFunction<T,R,V> b)
```

**allOf/anyOf**

- 组合<font color="red">**任意多个**</font>CompletableFuture
- allOf：<font color="red">所有</font>这些CF执行完成后才执行，无返回值（因为它组合的所有CF的返回值类型可能都不同）
- anyOf：<font color="red">任何一个</font>CF执行完成后就执行，返回类一定是Object，调用get得到的是第一个执行完的那个CF的返回对象
- 他们都是CompletableFuture的static方法，参数传进CF[]也可以
- 一般构建这两个之后，会在他们后面再加一个thenApply，thenApply里面的才是后续的处理

```java
public static CompletableFuture<Void> allOf(CompletableFuture<?>...cfs)
public static CompletableFuture<Object> anyOf(CompletableFuture<?>...cfs)
```

#### 异步任务异常处理



### 12.为什么会出现线程不安全问题

线程不安全指在多线程环境下，对于同一份数据访问时可能会出现数据混乱、数据值与预期不一致、数据丢失等现象

原因1（内存层面）：JVM有线程共享区域，如堆中的对象

原因2（CPU层面）：每个线程都会占用CPU的时间片，时间片到了该线程就要保存当前的状态，下一次再轮到这个线程执行时再加载这个任务的状态，也就是说一个线程不能一直占用CPU

原因3（操作层面）：线程中的操作不满足<font color="red">原子性</font>（每个操作中的几步不能被打断，如i++有读取i旧值、在工作内存把i+1、更新主内存中的i这3步，不能中间被打断）、<font color="red">可见性</font>（一个线程对某个值修改之后，其他线程要立刻看到这个修改）、<font color="red">有序性</font>（强制程序执行顺序按照代码先后顺序）

### 进程间通信的方式有哪些

- 管道（匿名管道）：数据只能单向流动（半双工通信），<font color="red">先进先出</font>，只能用于有血缘关系的父子进程间。**本质上是一个共享文件，在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作**。只有在被写入的内容被读取后，写入方才可以正常退出。

  linux命令中的|就是管道，作用是将前一个命令的输出作为后一个命令的输入

- 有名管道：不需要和创建有名管道的进程存在亲缘关系，只要可以访问管道的路径，就能够通过有名管道互相通信。

- 消息队列：本质是一个**存放在内存中的消息的链表**，消息是一个自定义的数据结构，如果进程从消息队列里读取了某个消息，这个消息就会被从消息队列中删除。<font color="red">不一定非要先进先出，可以随机查询，也可以按消息类型读取</font>。
- 共享内存：设置一个内存区域，该区域可以被多个进程访问，多个进程将同一段物理内存映射到它们各自的逻辑地址空间中
- 信号量和PV操作：一种锁机制，用于控制多个进程对共享资源的访问。信号量表示某种共享资源的数量，PV操作是一对原语，P操作表示将信号量值-1，表示申请占用一个资源，V操作表示将信号量值+1，表示释放一个资源。信号量值大于0表示有共享资源可供使用。
- 信号：注意和信号量是两个不同概念。是一种<font color="red">异步通信机制</font>，可以在任何时候发送信号给某个进程，通知进程执行某个操作。
- 套接字（sockets）：通过<font color="red">网络</font>**跨主机**进行通信

## Spring

### 1、spring控制反转的意义

每个对象可能依赖了很多个对象，将对象之间的相互依赖关系交给IOC容器管理，并由IOC容器完成对象的注入，这样可以很大程度上简化应用的开发。

例如：A依赖了B、C，B又依赖了D，如果不用IOC，那么当创建一个A对象时，需要set B、C对象，而传入B对象之前又需要构造D……等于是创建一个对象之前必须摸清它的所有依赖关系。而用了IOC就不需要这样了，直接交由容器解决这些依赖问题。

### 1、Spring用了哪些设计模式

- **工厂模式：**通过BeanFactory创建bean

- **代理模式：**AOP将增强代码织入目标中，就生成了一个被修饰的代理

- **单例模式：**bean默认是单例的

- **模板方法模式：**Spring中使用了很多模板，例如JDBCTemplate、RedisTemplate

- **策略模式：**Spring需要加载很多资源，需要使用Resource接口，这个接口有很多种实现类，不同的实现类有不同的资源加载方式，如ClassPathResource是通过类路径加载，UrlResource通过url进行加载等，根据不同的条件使用不同的实现类，然后用不同的加载策略

- **观察者模式：**Spring的<font color="red">事件驱动模型</font>——事件(ApplicationEvent)、事件监听者(ApplicationListener)、事件发布者(ApplicationEventPublisher，或者用它的子类ApplicationContext)，当调用事件发布者的publishEvent方法发布事件时，事件监听者的监听函数会被调用

  ![image-20231004214334180](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231004214334180.png)

### 2、Spring bean生命周期

Bean的生命周期完全由IOC容器进行管理（注意这里指单例bean）

【总结】主要就是实例化、属性赋值、初始化、使用、销毁这5步。

- 实例化：bean容器找到这个bean的定义然后利用反射机制创建一个bean的实例
- 属性赋值：为这个bean设置相关属性及注入依赖的其他bean
- 初始化阶段比较复杂一些，有多个扩展点
  - 先检查是否实现了Aware相关接口，如果是的话就执行相应的方法
  - 看是否有和加载这个bean的spring容器相关的BeanPostProcessor对象，有的话执行`postProcessBeforeInitialization()` 方法
  - 如果 <font color="orange">Bean 实现了`InitializingBean`接口</font>，执行`afterPropertiesSet()`方法。
  - 如果<font color="orange"> 定义了initMethod </font>，执行指定的方法。
  - 看是否有和加载这个bean的spring容器相关的BeanPostProcessor对象，有的话执行`postProcessAfterInitialization()` 方法

- 销毁
  - 在完成初始化后、使用之前，注册Destruction相关回调接口
  - 如果实现了 `DisposableBean` 接口</font>，执行 `destroy()` 方法。
  - 如果定义了destroyMethod</font>，执行指定的方法。

##### （1）实例化

**Bean容器找到bean的定义，并利用java reflection api创建一个bean的实例**

1. Bean 容器找到配置文件中 Spring Bean 的定义。
2. Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。

##### （2） 属性赋值

**若涉及属性值则用set方法设置属性值，如果实现了一些xxxAware接口就调用相应的方法**

3. 如果涉及到一些属性值 利用 `set()`方法设置一些属性值。
4. 如果 Bean 实现了 `BeanNameAware` 接口，调用 `setBeanName()`方法，传入 Bean 的名字。
5. 如果 Bean 实现了 `BeanClassLoaderAware` 接口，调用 `setBeanClassLoader()`方法，传入 `ClassLoader`对象的实例。
6. 如果 Bean 实现了 `BeanFactoryAware` 接口，调用 `setBeanFactory()`方法，传入 `BeanFactory`对象的实例。
7. 与上面的类似，如果实现了其他 `*.Aware`接口，就调用相应的方法。

##### （3）初始化

**根据情况执行postProcessBeforeInitialization()方法、afterPropertiesSet()方法、init-method相关方法、postProcessAfterInitialization()方法**

8. 如果<font color="orange">有和加载这个 Bean 的 Spring 容器相关的 `BeanPostProcessor` 对象</font>，执行`postProcessBeforeInitialization()` 方法
9. 如果 <font color="orange">Bean 实现了`InitializingBean`接口</font>，执行`afterPropertiesSet()`方法。
10. 如果<font color="orange"> Bean 在配置文件中的定义包含 init-method 属性</font>，执行指定的方法。
11. 如果<font color="orange">有和加载这个 Bean 的 Spring 容器相关的 `BeanPostProcessor` 对象</font>，执行`postProcessAfterInitialization()` 方法

##### （4） 销毁

**根据情况执行destroy()方法、destroy-method相关方法**

12. 当要销毁 Bean 的时候，如果<font color="orange"> Bean 实现了 `DisposableBean` 接口</font>，执行 `destroy()` 方法。
13. 当要销毁 Bean 的时候，如果 <font color="orange">Bean 在配置文件中的定义包含 destroy-method 属性</font>，执行指定的方法。

![](https://images.xiaozhuanlan.com/photo/2019/b5d264565657a5395c2781081a7483e1.jpg)

![img](https://img-blog.csdnimg.cn/20210707225212729.png?)

### 3、Spring如何处理依赖倒置（三级缓存）

注意：

- 循环依赖一定是单例bean的场景，<font color="red">**多例bean不支持循环依赖**（因为spring容器不缓存多例类型的bean，无法提前曝光）</font>，会直接抛出异常
- 循环依赖有属性相互引用（setter注入或Field注入）、基于构造器的循环依赖两种，spring<font color="Red">**只支持属性相互引用的循环依赖，不支持基于构造器的循环依赖**（因为某一对象要进入三级缓存的前提条件是已经完成初始化第一步——调用构造方法实例化该对象）</font>。

spring初始化一个对象需要经过以下三个步骤（函数doCreateBean的三步）：

1. **createBeanInstance：**实例化，调用对象的构造方法实例化该对象（构造器循环依赖会发生在此处）
2. **populateBean：**填充属性（属性相互引用循环依赖会发生在此处）
3. **initializeBean：**调用spring xml中的init方法

循环依赖解决方法——<font color="red">**三级缓存**</font>

```java
//一级缓存：存已经完成初始化三步的对象
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(64);

//二级缓存：存从三级缓存中升上来的对象
private final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16);

//三级缓存：存已经完成初始化第一步，但还未完成2、3步的对象
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);
```

步骤:

1.Spring首先从<font color="red">一级缓存singletonObjects</font>中获取。

2.如果获取不到，并且对象正在创建中，就再从<font color="red">二级缓存earlySingletonObjects</font>中获取。

3.如果还是获取不到且允许singletonFactories通过getObject()获取，就从<font color="Red">三级缓存singletonFactory.getObject()</font>获取.

4.如果从三级缓存中获取到就从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是<font color="red">从三级缓存移动到了二级缓存</font>。

例子：

A类的某个field或者setter依赖了B的实例对象，同时B类的某个field或者setter依赖了A的实例对象。当create A对象时，完成createBeanInstance之后（也就是调用构造方法实例化该对象之后），该对象已经被生产出来了，可以通过对象引用定位到堆中的这一个对象，但还不完美（第2、3步还未做），此时spring将A对象提前曝光到<font color="Red">三级缓存singletonFactories中</font>，随后进行初始化第2步，为A对象填充属性，然后发现有一个B的实例对象，这时候就去get(B)，但发现B还没有被create，所以去create B，开始B的初始化三步，第一步完成之后也把B提前曝光到<font color="red">三级缓存singletonFactories中</font>，然后第二步的时候发现自己有个属性对象A，于是也get(A)，先到一级缓存里看发现没有，再到二级缓存看也没有，最后到三级缓存看发现有，也就是通过ObjectFactory.getObject(A)拿到了A对象，并且<font color="red">把A升入二级缓存中</font>，B拿到A之后就顺利完成了第2、3步，初始化完成，然后<font color="red">B升进一级缓存</font>。随后返回A的初始化过程，这时候B已经完成了初始化并放到了一级缓存中，所以A就拿到了B并完成2、3步，然后<font color="red">也升到了一级缓存中</font>。

```java
/**
     * bean对象初始化三步
     */
    protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) {
        // Instantiate the bean.
        BeanWrapper instanceWrapper = null;
        .....
        
        if (instanceWrapper == null) {
            instanceWrapper = createBeanInstance(beanName, mbd, args);
        }
        .....
        // Eagerly cache singletons to be able to resolve circular references
        // even when triggered by lifecycle interfaces like BeanFactoryAware.
        boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
                isSingletonCurrentlyInCreation(beanName));
        if (earlySingletonExposure) {
            if (logger.isDebugEnabled()) {
                logger.debug("Eagerly caching bean '" + beanName +
                        "' to allow for resolving potential circular references");
            }
            //添加到三级缓存中
            addSingletonFactory(beanName, new ObjectFactory<Object>() {
                @Override
                public Object getObject() throws BeansException {
                    return getEarlyBeanReference(beanName, mbd, bean);
                }
            });
        }
 
        // Initialize the bean instance.
        Object exposedObject = bean;
        try {
            //填充依赖的bean实例。
            populateBean(beanName, mbd, instanceWrapper);
            if (exposedObject != null) {
                //调用spring xml中的init 方法。
                exposedObject = initializeBean(beanName, exposedObject, mbd);
            }
        }
        ......
        return exposedObject;
    }
```

到三个缓存中取bean的过程：

```java
/**
     * 到三个缓存中根据bean的名字取得单例bean对象。
     * 检查已经实例化的单例，也允许对当前创建的单例对象的早期引用(用于解决循环依赖)
     */
    protected Object getSingleton(String beanName, boolean allowEarlyReference) {
        //Spring首先从一级缓存singletonObjects中获取。
        Object singletonObject = this.singletonObjects.get(beanName);
 
        //isSingletonCurrentlyInCreation()判断当前单例bean是否正在创建中，也就是没有初始化
        //完成(比如A的构造器依赖了B对象所以得先去创建B对象， 或则在A的populateBean过程中依
        //赖了B对象，得先去创建B对象，这时的A就是处于创建中的状态。)
        if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
            synchronized (this.singletonObjects) {
 
                //尝试从二级缓存earlySingletonObjects中获取。
                singletonObject = this.earlySingletonObjects.get(beanName);
 
                //allowEarlyReference 是否允许从singletonFactories中通过getObject拿到对象
                if (singletonObject == null && allowEarlyReference) {
                    //尝试从三级缓存singletonFactory.getObject()(三级缓存)获取
                    ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
 
                    //如果从三级缓存中获取到
                    // 则从singletonFactories中移除，并放入earlySingletonObjects中。
                    // 其实也就是从三级缓存移动到了二级缓存。
                    if (singletonFactory != null) {
                        singletonObject = singletonFactory.getObject();
                        this.earlySingletonObjects.put(beanName, singletonObject);
                        this.singletonFactories.remove(beanName);
                    }
                }
            }
        }
        return (singletonObject != NULL_OBJECT ? singletonObject : null);
    }
```

##

### 4、Spring bean作用域及作用域配置方法

 **Bean的作用域**

- **singleton（单例，<font color="red">默认</font>）：**IOC容器中每个类只有唯一的一个实例对象。<font color="grey">目的：提高性能、少创建实例、减少垃圾回收、缓存快速获取</font>

  <font color="blue">在多线程的情况下存在竞争统一资源的问题</font>

- **prototype（多例）：**每次获取都会创建一个新的 bean 实例。也就是说，连续 `getBean()` 两次，得到的是不同的 Bean 实例。

- **request（仅web应用可用）：**每次http请求都会产生一个新的bean<font color="orange">（请求bean）</font>，且该bean<font color="red">仅在当前http request内有效</font>。

- **session（仅web应用可用）：**每一次来自新 session 的 HTTP 请求都会产生一个新的 bean<font color="orange">（会话 bean）</font>，该 bean <font color="red">仅在当前 HTTP session 内有效</font>。

- **websocket（仅web应用可用）：**每一次<font color="red"> WebSocket 会话产生一个新的 bean</font>。

**Bean作用域的配置方法**

- xml方式，<font color="red">scope属性</font>

  ```xml
  <bean id="..." class="..." scope="singleton"></bean>
  ```

- 注解方式，<font color="red">@Scope注解</font>

  ```java
  @Bean
  @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
  public Person personPrototype() {
      return new Person();
  }
  ```

### 5、Spring MVC如何获得前端http传来的参数

1. **@RequestParam注解接收<font color="red">简单参数（基本数据类型及一些包装类）</font>**

- value：请求的参数名，如果不设置，默认为注解后的形参名。这里要写的是<font color="red">前端对应的对象名称</font>，也正因为此，<font color="red">方法的形参名和前端对应的的对象名称可以不同</font>，例如下面的例子里前端对象名为bb，后端形参为b）
- name：由于在源码中，name的别名是value，value的别名是name，所以name等同于value。
- required ：表示该参数是否为必须，默认值为true，若请求的参数没有该参数，那么就会抛出异常。
- defaultValue：表示参数的默认值，如果设置了默认值后，required就直接为false，无论你是否设置了required值。

```java
    @RequestMapping("/test")
    public void mytest(@RequestParam(required = true) String a,@RequestParam(value =
                     "bb")Integer b,@RequestParam(defaultValue = "test123")String c){
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
    }

```

2. **@RequestBody注解接收<font color="red">json格式的参数，也就是可以接受一个自定义JAVA对象</font>**

注意：请求方式必须为POST

```java
@RequestMapping("/test2")
public void mytest2(@RequestBody User user){
    System.out.println(user.toString());
}

```

**3.@PathVariable占位符接收来自路径里的参数**

```java
 @RequestMapping("/test3/{name}/{age}")
 public void mytest3(@PathVariable String name,@PathVariable Integer age){//两个参数对应的就是上面路径中的{name}和{age}
    System.out.println(name);
    System.out.println(age);
 }
```

请求：

![](https://img-blog.csdnimg.cn/20200604113315586.png)

结果：

![](https://img-blog.csdnimg.cn/20200604113338360.png)

**4.不使用注解，直接在方法中定义参数**

可以实现简单对象和复杂对象的接收

1. 如果绑定的对象是简单类型： 调用@RequestParam来处理的。
2. 如果绑定的对象是复杂类型： 调用@ModelAttribute来处理的。

需要注意的是<font color="red">参数名必须和前端对应的对象名相同</font>

```java
@RequestMapping("/test4")
public void mytest4(User user,String a,String nickname){
    System.out.println(user.toString());
    System.out.println(a);
    System.out.println(nickname);
}
```

### 6.@resource和@autowired这两个注解有什么不同？

- `@Autowired` 是 Spring 提供的注解，`@Resource` 是 JDK 提供的注解。
- `Autowired` 默认的注入方式为`byType`（根据类型进行匹配），`@Resource`默认注入方式为 `byName`（根据名称进行匹配）。
- 当一个接口存在多个实现类的情况下，`@Autowired` 和`@Resource`<font color="red">都需要通过byName才能正确匹配到对应的 Bean</font>。`Autowired` 可以通过再在下面加一个 <font color="red">`@Qualifier` 注解</font>来显式指定名称，`@Resource`可以通过 <font color="red">`name` 属性</font>来显式指定名称。
- @Autowired可以用于构造方法、setter方法、属性上，@Resource不能用于构造方法。

### 7.spring、springboot、springmvc、springcloud

区别：

- **Spring**是一个框架，包含多个功能模块，如Spring-Core（主要提供 IoC 依赖注入功能的支持，spring中其他模块的功能实现基本都需要依赖该模块） 

- **Spring MVC**是Spring中的一个模块，主要赋予Spring快速构建MVC架构的Web程序的能力，MVC包括(model)、视图(view)、控制器(controller)，核心思想是通过将数据、显示、业务逻辑分离来组织代码。<font color="orange">【MVC架构：model持有<u>数据和状态</u>，view负责<u>接收来自用户的请求及展示</u>，controller连接model和view，<u>将用户的行为转化为对模型或视图的更改</u>】</font>

  ![image-20230917115318468](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230917115318468.png)

- **Spring Boot**是spring的完善和扩展，目的是简化配置，例如因为传统spring需要写大量xml等来配置依赖，比较麻烦，而springboot只需要通过一些注解；又如在测试的时候，在传统spring中，需要在maven依赖里添加Spring Test、JUnit 、Mockito、Hamcrest依赖，而在spring boot中只需要添加 spring-boot-starter-test 依赖项来自动包含这些库。

  使用传统Spring创建web应用程序所需的最小依赖项：

  ```xml
  <dependency> 
      <groupId>org.springframework</groupId> 
      <artifactId>spring-web</artifactId> 
      <version>5.1.0.RELEASE</version> 
  </dependency> 
  <dependency> 
      <groupId>org.springframework</groupId> 
      <artifactId>spring-webmvc</artifactId> 
      <version>5.1.0.RELEASE</version> 
  </dependency>
  ```

  使用Springboot只需一个依赖：

  ```xml
  <dependency> 
      <groupId>org.springframework.boot</groupId> 
      <artifactId>spring-boot-starter-web</artifactId> 
      <version>2.0.6.RELEASE</version> 
  </dependency>
  ```

- **Spring cloud**是一整套基于spring boot的微服务解决方案，提供了配置管理、服务注册与发布等快速构建微服务系统的组件

联系：

在构建一个web应用程序时，可以使用spring MVC提供的分层框架，然后通过springboot来简化配置，如果要构建基于spring boot的微服务架构系统，可以利用上spring cloud

### 8.Spring AOP实现原理

AOP(Aspect-Oriented Programming:面向切面编程)能够将那些<font color="red">与业务无关，却为业务模块所共同调用的逻辑或责任（例如安全处理、事务处理、日志管理、权限控制等）</font>封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

**spring AOP基于<font color="red">动态代理</font>**:

- 如果要代理的对象，实现了某个接口，使用 **JDK Proxy**去创建代理对象
- 如果要代理的对象没有实现任何接口，使用 **Cglib**去创建代理对象

<font color="voilet">Spring AOP和AspectJ AOP的区别：AspectJ是静态AOP代理，在编译阶段对程序源代码进行修改；spring AOP是运行阶段动态生成代理对象，**切面较多时建议选择AspectJ，因为效率更高**,Spring AOP也集成了AspectJ</font>

**AOP术语：**

| 术语              | 含义                                                         |
| ----------------- | ------------------------------------------------------------ |
| 通知(Advice)      | 就是你想要的功能，即就是上面说的 安全，事务，日志等          |
| 连接点(JoinPoint) | spring<font color="red">允许使用通知的地方</font>，如每个方法的前、后、抛出异常时 |
| 切入点(Pointcut)  | <font color="red">真正使用了通知的连接点</font>              |
| 切面(Aspect)      | <font color="red">通知和切入点的结合</font>，一般通过@Aspect注解声明<font color="red">切面类</font>，切面类声明了我们要在什么时候做出什么样的增强行为 |
| 织入(Weaving)     | 把增强代码应用到目标上，生成代理对象的过程                   |
| 目标(Target)      | 被通知的对象，也就是<font color="red">真正的业务逻辑</font>，也就是被引入了那些安全、事务、日志的方法 |
| 代理(Proxy)       | 指生成的代理对象                                             |

**Spring AOP通知分类：**

![](https://img-blog.csdnimg.cn/502119ede09f499fa52a920794e413d7.png)

**切面类例子：**

```java
//描述切面类
@Aspect
@Configuration
public class TestAop {

    // 定义一个切入点，execution表示在这个执行时触发，第一个*表示返回任意类型，后面的com.test.service.CacheDemoService.find*表示该方法是com.test.service.CacheDemoService这个类下面的以find开头的所有方法，最后的(..)表示使用任意参数
    @Pointcut("execution(* com.test.service.CacheDemoService.find*(..))")
    public void excudeService(){}
    
    //前置通知：在切入点excudeService执行之前执行
    @Before("excudeService()")
    public void beforeAdvice(JoinPoint joinPoint){
        //获取方法名
        String methodName = joinPoint.getSignature().getName();
        //获取参数
        Object[] args = joinPoint.getArgs();
        System.out.println("前置通知： "+methodName+" 方法，参数： "+ Arrays.toString(args));
    }
    
    //后置通知，在方法执行之后执行，不管是否发生异常
    @After("excudeService()")
    public void afterAdvice(JoinPoint joinPoint){
        //获取方法名
        String methodName = joinPoint.getSignature().getName();
        System.out.println("后置通知： "+methodName+" 方法");
    }
    //返回通知，在方法返回结果之后执行
    //pointcut属性：指定切入点表达式，跟value属性功能一样；returning属性：获取方法的返回值，并指定通知方法中入参的形参名
    @AfterReturning(pointcut = "excudeService()",returning = "result")
    public void afterReturning(JoinPoint joinPoint, Object result){
        //获取方法名
        String methodName = joinPoint.getSignature().getName();
        System.out.println("返回通知： "+methodName+" 方法，返回： "+result);
    }

    //异常通知，在方法执行抛出异常时执行
    //pointcut属性：指定切入点表达式，跟value属性功能一样；throwing属性：获取异常信息，并指定通知方法中入参的形参名
    @AfterThrowing(value = "excudeService()",throwing = "e")
    public void afterThrowing(JoinPoint joinPoint,Throwable e){
        //获取方法名
        String methodName = joinPoint.getSignature().getName();
        System.out.println("异常通知： "+methodName+" 方法，异常： "+e);
    }
    
    //环绕通知，注意参数是ProceedingJoinPoint类型的
    @Around("excudeService()")
    public Object twiceAsOld(ProceedingJoinPoint thisJoinPoint){
        System.err.println ("切面执行了。。。。");
        try {
            Thing thing = (Thing) thisJoinPoint.proceed ();
            thing.setName (thing.getName () + "=========");
            return thing;
        } catch (Throwable e) {
            e.printStackTrace ();
        }
        return null;
    }
    
    

    //通过连接点切入，和上面的切入点excudeService没关系，这里弄了一个新的（只要看到有execution……这样的表达式都是在弄一个新的切点）
    //这里还使用了切入点的参数，并且打印了出来
    @Before("execution(* findById*(..)) &&" + "args(id,..)")
    public void twiceAsOld1(Long id){
        System.err.println ("切面before执行了。。。。id==" + id);
    }

}
```

### 9.JDBC java数据库连接过程

以连接mysql数据库为例

1. 首先要准备jdbcurl、userName和password

   ![image-20231004205919660](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231004205919660.png)

2. 加载JDBC驱动程序

   通过Class.forName("com.mysql.jdbc.Driver")

   ![image-20231004210514433](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231004210514433.png)

3. 通过之前的url、userName和password创建数据库连接

   ![image-20231004210641971](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231004210641971.png)

4. 创建Statement实例

   - 如果要执行静态SQL语句，那么创建Statement实例
   - 如果要执行动态SQL语句，那么创建PreparedStatement实例
   - 如果要执行数据库存储过程，那么创建CallableStatement实例

   ![image-20231004210655969](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231004210655969.png)

5. 调用之前Statement实例的execute/executeQuery/executeUpdate方法执行SQL语句，获得结果集（一个ResultSet对象）

   ![image-20231004211058471](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231004211058471.png)

6. 遍历结果集拿到里面的结果

   通过result.next()逐个拿到结果

   ![image-20231004211138863](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231004211138863.png)

7. 关闭资源，注意和声明的顺序相反，即先关闭ResultSet，再关闭Statement，最后关闭Connection

   

## Mysql

### 1、Mysql的索引有哪些类型

默认用b+树，另外还有hash索引、r树索引、全文索引等

- hash索引：<font color="red">键值对</font>的形式
- r树索引：MyISAM引擎的特殊索引类型，主要用于<font color="red">地理空间</font>类型
- 全文索引：可以解决一些<font color="red">针对文本的关键字查询</font>问题

### 2、解释B+树，使用B+树的好处、和B树比较B+树的好处

**mysql使用B+树做索引的好处：**

- 每个节点存的索引多，<font color="red">可以降低树的高度，减少磁盘IO</font>
- 所有数据都存在叶子节点，<font color="red">各个叶子节点到根的高度相同，使得索引更为稳定（查询不同的数据都需要从根->叶子节点，快慢程度相同）</font>。
- 叶子节点之间用<font color="red">双向链表</font>进行相连，有利于范围查询（先找到下界或上界，然后沿着链表遍历即可）

**和B树比较B+树的好处：**

- <font color="red">B树所有节点既存放键也存放数据</font>:
  - 同样大小的非叶子节点能存放的键数目更少，也就<font color="red">需要更多节点</font>
  - 各条数据到根的高度不同，<font color="Red">不够稳定（查询不同数据的快慢程度可能差很多）</font>
- B+树的叶子节点之间有<font color="Red">双向链表</font>相连，范围查询的时候找到边界然后沿着链表遍历即可；B树没有，范围查询的时候要先找到边界然后做中序遍历，<font color="red">B+树比B树更适合范围查询</font>。

**mysql的k阶B+树索引结构：**

![](https://img2020.cnblogs.com/blog/1313648/202107/1313648-20210722094807990-431801600.png)

- <font color="red">非叶子节点的关键字个数就是它的子节点的个数（网上的资料说这个存在争议，但mysql索引实现的是这样）</font>，且<font color="red">值是所指向的子节点的最小的关键字（左闭合原则）</font>，设非叶子节点的关键字个数为m（即子节点个数），则，<font color="red">**ceil(k/2)≤m≤k**</font>
- 根节点的<font color="red">**2≤m≤k**</font>
- 叶子节点之间通过<font color="red">双向链表</font>相连

InnoDB引擎默认每个表都会建立<font color="red">聚簇索引（以主键为索引）</font>，叶子节点存放的是<font color="red">整行数据</font>

非聚簇索引：<font color="red">非主键索引</font>，叶子节点存的是对应那行的<font color="red">主键</font>，所以要根据这个主键再去遍历聚簇索引（叫做<font color="red">“回表”</font>）

MyISAM引擎的主键索引和非主键索引叶子节点存的都不是整行数据，而是那一行的<font color="red">地址。</font>



### 3、Mysql distinct去重机制

distinct关键字可以针对单一字段进行去重，也可以针对多个字段进行去重，例如：

![](https://img-blog.csdnimg.cn/b831a80023114250932a3ec7ebbe2070.png)

针对单一字段去重：

```mysql
SELECT DISTINCT PLAN_NUMBER FROM psur_list;
```

![](https://img-blog.csdnimg.cn/4847eb0643cd4024aafa685e9a7bbb82.png)

针对多个字段拼接成的记录去重：

```mysql
SELECT DISTINCT PLAN_NUMBER,PRODUCT_NAME FROM psur_list;
```

![](https://img-blog.csdnimg.cn/0045e37bbe094552b6701a2a6eb9c871.png)

如果在select多个字段的情况下，期望对某一个字段进行去重：加上group_concat关键字

```mysql
SELECT GROUP_CONCAT(DISTINCT PLAN_NUMBER) AS PLAN_NUMBER,PRODUCT_NAME from psur_list GROUP BY PLAN_NUMBER
```

![](https://img-blog.csdnimg.cn/73cadf7faf61459f879f40d637d66377.png)

**distinct的去重机制：**

- 先得到未去重的数据，然后对这些数据进行<font color="red">分组**（其实就是group by）**，然后每个分组取一条数据</font>
  - 如果distinct的字段**全部包含索引**，则分组是直接通过**操作索引**进行，<font color="red">索引已排序，可以利用这个排序特性，每更换一个索引值时取一条数据</font>
  - 如果distinct的字段**未全部包含索引**，则需要用到**临时表**，mysql首先需要将满足条件的数据放到临时表中，然后在临时表中对该部分数据进行分组，然后从临时表中每个分组的数据中取一条数据。<font color="red">但在这个临时表中不会对数据进行排序（这个是和group by的不同，group by通过临时表分组之后，默认会进行排序，如果不需要顺序，用 order by null）</font>

### 4、事务的四个关键属性(ACID)

| 属性    | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| 原子性A | 事务包含的一组更新操作是原子不可分的，要么全部成功，要么全部失败回滚（如i++包含从主内存读取i、在工作内存把i+1、把新的值写回到主内存这三个步骤） |
| 一致性C | 事务执行前后数据库都要处于一致性状态（如银行转账系统A转钱给B前后总钱数一样多） |
| 隔离性I | 当多个用户并发访问数据库时，数据库为每个用户开启的事务不能被其他事务干扰，多个并发事务要相互隔离 |
| 持久性D | 一旦事务提交，所作的修改要永远保存到数据库中，即使系统崩溃也不能丢失 |

- **原子性：**事务包含的一组更新操作是原子不可分的，要么全部提交成功，要么全部失败回滚（系统在做操作前，会先在磁盘上将操作存储下来），如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响

- **一致性：**指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。一个事务所做的修改在最终提交以前，对其它事务是不可见的。

  举例来说，假设用户A和用户B两者的钱加起来一共是1000，那么不管A和B之间如何转账、转几次账，事务结束后两个用户的钱相加起来应该还得是1000，这就是事务的一致性。

- **隔离性：**隔离性是当多个用户并发访问数据库时，比如同时操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离

- **持久性：**一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失

**为什么要有这四个属性呢？**

<img src="G:\研一下\找实习\InterviewExperience\阿里\事务四个属性.png" alt="事务四个属性" style="zoom:50%;" />

- 只有满足一致性，事务的执行结果才是正确的
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性
- 事务满足持久化是为了能应对系统崩溃的情况

#### mysql如何实现ACID

原子性：undo log（异常或失败回滚）、隔离性：锁+MVCC（当前读、快照读）、持久性：redo log（当MySQL突然宕机时，可以通过redo log将数据保存至磁盘中）

一致性：前面三个特性就是为了最终保证一致性

### 5、事务隔离级别

**为什么要设置事务隔离级别？**

在数据库操作中，在并发的情况下可能出现如下问题：

| 名称       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 更新丢失   | 更新被覆盖                                                   |
| 脏读       | 读到了其他事务未提交的数据                                   |
| 不可重复读 | 同一事务对同一行读取两次，两次读取到的结果不同，因为另一事务在这期间对这行做了修改。 |
| 幻读       | （本质上也属于不可重复读，但是指一定范围的多行）同一事务两次读取某一范围的数据时读到不同的结果，因为另一事务在这期间insert了新的行 |

不可重复读侧重的是<font color="red">数据的修改</font>，幻读侧重的是<font color="red">数据的新增或删除</font>。解决不可重复读，只用<font color="red">锁住行</font>，而解决幻读，需要<font color="red">锁住整张表</font>。

+ **更新丢失**（Lost update）：更新被覆盖
+ **脏读**（Dirty Reads）：读到另外事务未提交的数据
+ **不可重复读**（Non-repeatable Reads）：一个事务对同一行数据重复读取两次，但是却得到了不同的结果（另一事务也访问了该同一数据集合并做了修改）
+ **幻影读**：本质上也属于不可重复读的情况，但只是指新insert的行。T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同

**所以设置了四个隔离级别，由低到高依次为：**

| 名称                           | 描述                                                         | 解决的问题                 | 没解决的问题                           |
| ------------------------------ | ------------------------------------------------------------ | -------------------------- | -------------------------------------- |
| 未提交读                       | <font color="red">一个事务读的时候没有限制，写的时候其他事务不能写但可以读</font>，所以这个事务进行的更新操作不会丢失但它未提交的数据会被其他事务读到， | 更新丢失                   | 脏读、不可重复读、幻读                 |
| 已提交读（大多数数据库默认的） | <font color="red">一个事务读的时候没有限制，写的时候在提交之前别的事务不能读也不能写</font>，从而避免读到未提交的数据，但读操作没有限制，所以两次读取还是可能不同 | 更新丢失、脏读             | 不可重复读、幻读                       |
| 可重复读（mysql默认的）        | <font color="red">读时禁止写（只是禁止对现在读取的行进行写，还是可以insert新的行），写时禁止任何</font>，保证同一事务中多次读取的结果一样 | 更新丢失、脏读、不可重复读 | 幻读（因为加的锁是行级锁，不是表级锁） |
| 可串行化                       | 所有事务串行执行                                             | 所有                       | -                                      |

- **未提交读（READ UNCOMMITTED）**：如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据

  <u>避免了更新丢失，却可能出现脏读</u>。因为事务B可能读取到事务A未提交的数据

- **提交读（READ COMMITTED）**：读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行

  <u>避免了脏读，但是却可能出现不可重复读</u>。如事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变

- **可重复读（REPEATABLE READ）**：保证在同一个事务中多次读取同一数据的结果是一样的，这样在这个事务还没有结束时，另外一个事务也访问该同一数据。读事务将禁止写事务（但允许读事务），写事务则禁止任何其他事务

  <u>避免了不可重复读取和脏读，但是有时可能出现幻象读</u>。如T1改完数据后，T2又插入了一个，而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读

- **可串行化（SERIALIZABLE）**：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题

### 6、InnoDB和MyISAM的区别

1. <font color="red">InnoDB支持事务，MyISAM不支持，</font>InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务
2. <font color="red">InnoDB支持外键，MyISAM不支持</font>
3. <font color="red">InnoDB是聚簇索引</font>，且表数据直接就存在主键索引的叶子节点，通过主键索引效率很高，但非主键索引需要两次查询；<font color="red">MyISAM是非聚簇索引</font>，主键索引和非主键索引是分开的，非主键索引不需要二次查询。InnoDB的主键索引中的叶子节点放的是<font color="red">整行数据</font>，非主键索引的叶子节点放的是<font color="red">主键</font>，使用非主键索引时要根据这个主键再去聚簇索引那里拿那行数据（回表）；MyISAM的主键和非主键索引的叶子节点放的都是那一行的<font color="red">地址</font>，是根据这个地址去拿数据
4. <font color="red">InnoDB不保存整个表的行数</font>，执行select count(\*) from table时需要全表扫描。而<font color="red">MyISAM用一个变量保存了整个表的行数</font>，执行上述语句时只需要读出该变量即可
5. <font color="red">InnoDB支持表、行级锁（默认行级），MyISAM只支持表级锁</font>

### 7、Mysql InnoDB的锁机制

innoDB几种锁：

- 按粒度分：行级锁（共享锁/排他锁）、表级锁（共享锁/排他锁、意向共享锁/意向排他锁）、全局锁（锁整个数据库，一般是全局备份/导出的时候用，用的比较少）
- 按锁定范围：记录锁（只锁定那一行）、间隙锁（锁定一个开区间，行不会被锁定）、临键锁（<font color="red">左开右闭</font>，锁定记录和区间）

<font color="Red">在获得行级锁之前必须要获得表级的意向锁</font>

在对某个表加锁之前，必须保证这个表的任何一行都不能被加锁（除了一种情况：加表级S锁时允许存在行级S锁），这时候直接检查这个表的意向锁即可，不需要一行行地检查。除了S和IS不互斥之外，别的表锁都和意向锁互斥。<font color="red">意向锁存在的目的就是当加表锁的时候不需要一行行地看是否存在行级锁</font>

锁的互斥性：

- 行级

  ![image-20230811003948532](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230811003948532.png)

- 表级

  - 意向锁之间互相兼容——因此对不同的行加任何行级锁都是不会互斥的

    ![image-20230811004120072](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230811004120072.png)

  - 除了IS锁兼容表级S锁外，意向锁和表级S/X锁互斥（注意意向锁不会和行级S/X锁互斥）——因此当一个事务想对一个表加表级S/X锁时，除非现在这个表里已有的行级锁都是S锁，且要加的表锁是S锁，否则不能加任何表锁）

    ![image-20230811004216939](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230811004216939.png)

锁的使用：

- 加行级S锁：SELECT...LOCK IN SHARE MODE;
- 加行级X锁：SELECT...FOR UPDATE（注意这个虽然是读取语句但加的也是排他锁）;、INSERT...;、UPDATE...;、DELETE...;
- 加表级S锁：LOCK TABLES 表名 READ;
- 加表级X锁：LOCK TABLES 表名 WRITE;
- 加全局S/X锁：FLUSH TABLES WITH READ LOCK、FLUSH TABLES WITH WRITE LOCK
- 释放表S/X锁、全局S/X锁：UNLOCK TABLES

记录锁、间隙锁、临键锁（全是行级锁）

- 记录锁锁定的是表中<font color="red">单个记录</font>，间隙锁锁定的是一个<font color="red">左开右开的区间</font>，临键锁是记录锁+间隙锁，锁定的是一个<font color="red">左开右闭的区间</font>
- 产生记录锁的条件：
  - 查询语句使用<font color="red">**单个**主键索引或非主键的唯一索引</font>，且是<font color="red">=精准匹配，只锁定一行或者该记录不存在（记录不存在的时候若使用的是单个唯一索引，则同时产生记录锁和间隙锁）</font>，例如当一个事务执行`select * form A where id=100 for update`时，将id=100的行加上记录锁
  - 记录锁对<font color="red">索引项</font>的锁定，如果表没有索引，则innoDB会对隐藏的聚簇索引隐式创建一个记录锁。记录锁可以防止其他事务修改或删除同一行。

- 产生间隙锁的条件：
  - 在RR隔离级别下，避免幻读
  - 查询语句使用的是<font color="red"><u>单个或多个非唯一索引</u>(此时同时产生了临键锁和间隙锁）、<u>多个唯一索引</u>、<u>使用单个唯一索引进行范围查询锁定多行</u>、<u>查询不存在的记录</u>（记录不存在的时候若使用的是单个唯一索引，则同时产生记录锁和间隙锁）</font>

- 产生临键锁的条件：
  - 在RR隔离级别下，避免幻读
  - 查询语句使用的是<font color="red"><u>单个或多个非唯一索引</u>（此时同时产生了临键锁和间隙锁）</font>

举例



mysql乐观锁：一种思想，不是具体的一个锁，就是加一个版本号，更新的时候判断这个版本号是否符合预期，符合的话再更新，并且更新时连同版本号+1

### 8、where和having的区别，什么时候要用having

在查询过程中执行顺序（除了select是最后才执行但写在第一个外，其他的其实也是数据库语句的书写顺序）：**from>where>group（含聚合）>having>order>select。**

因此聚合函数（sum、min、max、avg、count等）在having语句之前执行，在where语句之后执行，因此

<font color="red">having子句用来筛选分组（或聚合）后的各组数据</font>，也可以在聚合后对组记录进行筛选，而<font color="red">where子句在分组（或聚合）前先筛选记录</font>。

having一定要跟着group by一起使用，需要写在group by后面

因此，如果是要筛选聚合或分组前的条件（如某个字段等于某个值）时用where，筛选聚合或分组后的条件（如count行数大于2，avg大于10，满足某个条件的分组这种）用having

- 例如：有一个表记录了所有用户的发帖记录，求发帖数量大于10的所有用户

  ```mysql
  select user_id, count(*)
  from post
  group by user_id
  having count(*)>10;
  ```

<font color="orange">一个小点：having子句中聚合函数可以和具体数字作比较，如上面的having count(*)>10，但不能和表中的一个字段做比较，如having user_id>avg(user_id)这样不行，要结合表连接才行，就是把avg(user_id)又写成一个select语句</font>

### 9.mysql的联合索引和索引失效

#### 索引操作语句

- 单独创建索引

  - 一次只能创建一个，且必须提供索引名称

  ```mysql
  CREATE INDEX 表名 ON 索引名(column1 [ASC|DESC], column2 [ASC|DESC], ...);
  ```

  - 一次可以创建多个，且可以不指定索引名称，mysql提供一个默认语句

    ```mysql
    ALTER TABLE 表名 ADD INDEX 索引名1(column1 [ASC|DESC], column2 [ASC|DESC], ...),  ADD INDEX 索引名2(column1 [ASC|DESC], column2 [ASC|DESC], ...),;
    ```

- 创建表的时候直接指定索引	

  ```mysql
  CREATE TABLE table_name (
    column1 data_type,
    column2 data_type,
    ...,
    INDEX 索引名(column1 [ASC|DESC], column2 [ASC|DESC], ...)
  );
  ```

- 建表时建立主键索引

  ```mysql
  -- 方式一：
  create table user1(
      id int primary key,     -- 在创建表的时候，直接在字段名后指定 primary key
      name varchar(30)
  );
   
  -- 方式二：
  create table user1(
      id int,
      name varchar(30),
      primary key(id)        -- 在创建表的最后，指定某列或某几列为主键索引
  );
  ```

- 删除索引

  ```mysql
  DROP INDEX 索引名 ON 表名;
  ```

- 修改表结构，删除索引

  ```mysql
  ALTER TABLE 表名 DROP INDEX 索引名;
  ```

- 删除主键索引（注意：如果该主键设置了auto_increment自增，则该主键索引无法被删除）

  ```mysql
   alter table 表名 drop primary key;
  ```


#### 联合索引

问：如果A,B,C,D四个字段设置了联合索引，有一个查询语句select * where A=a and C=c and D=d，问索引是否会失效

答案：A索引可以用上，但C、D失效了。因为根据最左前缀匹配原则，当设置了联合索引(a,b,c,d)时，设置的所有索引有A、AB、ABC、ABCD，这条语句能匹配上的只有A。

<font color="red">**联合索引的使用必须要符合最左前缀匹配原则才不会失效**</font>

**最左前缀匹配原则**

mysql在进行联合索引的匹配时，是按照<font color="red">**声明索引时的顺序从左到右**（注意不是where子句中的顺序，因为where子句中的顺序会经过查询优化器优化成最佳顺序）</font>进行匹配的，且遇到>、<时会结束后一步的匹配，也就是<font color="blue">含**>**、**<**的索引可以匹配但它后面的那个就不能匹配了</font>。（注意：>=、<=、BETWEEN、like 右模糊匹配这四种范围查询，并不会停止匹配，like左模糊查询是会直接使得索引失效，连like左模糊查询的字段都失效了，更不用说后面的了)。<font color="red">因此，在建立索引时，要把选择性高的字段放在左边。</font>

例子——当设置了索引(a,b,c)时：

- select * from t where a=1 and b=1 and c =1;     可以利用到定义的索引（a,b,c）,用上a,b,c
- select * from t where a=1 and b=1;     可以利用到定义的索引（a,b,c）,用上a,b
- select * from t where b=1 and a=1;     可以利用到定义的索引（a,b,c）,用上a,b
- select * from t where a=1;     可以利用到定义的索引（a,b,c）,用上a
- select * from t where b=1 and c=1;     不可以利用到定义的索引（a,b,c）,因为没有a
- select * from t where a=1 and c=1;     可以利用到定义的索引（a,b,c），但只用上a索引，b,c索引用不到
- select * from t where a=1 and b>1 and c =1;   可以利用到定义的索引（a,b,c），但只能用到a和b，c用不到；如果定义的索引是(a,c,b)的话那都可以用上了
- select * from t where a=1 and b>=1 and c =1;   可以利用到定义的索引（a,b,c）且abc都能用上，因为>=不会使得匹配结束

**会使得联合索引停止匹配的几个情况：**

- **>**、**<**：它自己可以匹配但它后面的就不能匹配了
- like左模糊查询：它本身以及它后面的都不能匹配

> \>=、<=、BETWEEN、like 右模糊匹配这四种范围查询，并不会停止匹配

  

#### 索引失效的情况

指整个索引都没有用上，而不是索引中的某些字段没用上

- 使用<font color="red">联合索引</font>但查询条件没有遵守<font color="red">最左前缀匹配原则（即索引最左边的字段不在where中）</font>
- 在索引列上进行<font color="red">计算、函数、类型转换</font>等操作
- Like<font color="Red">左模糊查询</font>，如 like '%abc'；注意<font color="red">右模糊查询</font>也就是 like 'abc%' 这样的是不会使得索引失效的
- 查询条件中使用 or，且 <font color="red">or 的前后条件中存在某个列没有索引</font>
- 发生<font color="red">隐式转换</font>的一些情况（where xx=xx的等号左右两边数据类型不一致时会发生隐式转换，当左边为数值类型时影响不大，但<font color="Red">左边为字符类型、右边为数字</font>时会导致索引失效）

### 9.覆盖索引

覆盖索引：就是包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引

对于非主键索引，<font color="red">如果所有查询字段被索引所包含，那么select的时候就不需要回表操作，降低了开销</font>。所以对于经常被查询的字段，非常建议使用覆盖索引。

另外，由于索引是按值的顺序存储的，因此在做<font color="red">范围查询</font>时可以利用索引，将随机IO变为顺序IO

### 10、当前读和快照读

- 快照读就是<font color="Red">普通的select</font>，没有用上面的加行级锁语句，如果读取的记录正在执行写操作，读取操作不会因此去等待记录上锁的释放，而是会去读取行的一个<font color="red">快照</font>。
  - 只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用快照读：
    - 在 RC 级别下，对于快照数据，快照读总是读取被锁定行的<font color="red">最新一份快照数据</font>。
    - 在 RR 级别下，对于快照数据，快照读总是读取<font color="red">本事务开始时的行数据</font>版本。
- 当前读就是给行加了S锁或X锁，对应的语句见上面，读的是当前已提交的最新数据

### 11.MVCC、undo log

用于解决在多个并发事务同时读写数据库时保持数据的一致性和隔离性，<font color="red">通过在每个数据行上维护多个版本的数据来实现</font>，当对某条记录进行更新时，会给这条记录增加一个新的版本，保留历史版本，而非直接对记录的数据进行覆盖（会定期回收没用了的版本）。

通过MVCC达成的效果：

- 快照读（普通select，注意当前读读的都是最新数据，没用MVCC）：
  - RR级别下，读取该事务第一次select开始前已提交的最新数据（原因：只有第一次select才生成了新的read view，后面的select都是复用第一次的read view，除了一种特殊情况：两次select之间有一次当前读，那后面的select又会生成新的read view）
  - RC级别下，读取每次select开始前该记录的最新已提交版本（原因：每次select操作都会生成一个新的read view）
- 写操作（update、insert、delete）：会<font color="Red">生成一个新的数据版本（undo log)</font>存入数据库，但之前的那些版本都还在

- 事务提交时，它所做的修改成为这条记录的最新版本；事务回滚时，他所做的修改将被撤销



**innoDB的MVCC底层实现**

通过**隐藏字段**、**undo log**和**read view**实现

- 每行数据添加3个隐藏字段：
  - **事务ID db_trx_id：**最后一次插入或更新改行的事务id（不一定提交，其实就是作为undo log的起点），另外delete操作在内部被视为更新，只不过在记录头`record header`中的`deleted_flag`字段将其标记为已删除
  
  - **回滚指针 db_roll_ptr：**回滚指针，该行上一个版本的 `undo log` 地址。如果该行未被更新，则为null

  - **行标识 db_row_id：**如果没有设置主键且该表没有唯一非空索引时，使用该id来生成聚簇索引，实际上并不是一个真实的列
  
    <font color="orange">（innoDB定义聚簇索引的规则：如果有定义<u>主键</u>那就用这个定义的主键，没有的话看是否有<u>唯一非空索引</u>，如果有多个的话就用建表时定义的第一个唯一非空索引，这个字段对应的就是那个索引，否则会自动生成<u>隐藏的行ID</u>来生成聚簇索引，这个行ID也会自增，但是所有表全局共享的）</font>
  
- undo log：有两种，insert undo log和update undo log
  
  - insert undo log：insert一条生成一个，因为insert操作在事务提交前只对当前事务可见，因此产生的undo日志可以在事务提交后直接删除

  - update undo log：每次对该行update或delete生成一个，事务提交后也不删除，因为要提供MVCC支持，后面由purge线程进行最后的删除
  
  - 记录的字段：就是每一行的记录加上事务ID、回滚指针，回滚指针指向该行记录的上一个undo log
  
    ![img](https://javaguide.cn/assets/6a276e7a-b0da-4c7b-bdf7-c0c7b7b3b31c-2e496ea1.png)
  
- read view

  - 生成时间：

    - RC级别：<font color="red">每次快照读</font>都生成一个（所以有不可重复读问题）
    - RR级别：<font color="red">第一个快照读时生成</font>，如果中间后面没有当前读，则后面的快照读用的都是第一次生成的，如果中间有当前读，那当前读后一次快照读会重新生成

  - 四个主要字段：
    - **m_ids：**当前活跃的（未提交或回滚）的所有事务ID列表 ，<font color="red">不包括自己</font>
    - **m_up_limit_id：**当前活跃事务ID列表中最小的事务ID
    - **m_low_limit_id：**下一个要分配的事务ID，即目前出现过的最大事务ID+1
    - **m_creator_trx_id：**创建这个read view的事务ID
    

- 可见性算法步骤

​		从记录的最新版本开始：

1. 如果<font color="red">事务ID<当前活跃事务最小ID</font>或<font color="red">事务ID=创建这个read view的事务ID</font>，表明这行就是这个事务修改的，或者修改这行的事务在创建这个read view之前就提交了，可见
1. 如果<font color="red">事务ID≥下一个要分配的事务ID</font>，表明这行在创建这个read view之后才进行修改，不可见
1. 如果<font color="red">当前活跃事务ID列表为空，</font>可见
1. 如果<font color="red">当前活跃事务最小ID≤事务ID＜下一个要分配的事务ID</font>，表明创建这个read view的时候修改这行的那个事务可能活跃了也可能已提交，这时候<font color="red">看m_ids是否有这个事务ID</font>，如果没有的话说明创建这个read view的时候这个事务已经提交了，可见，否则不可见
1. 如果上面的步骤都是不可见，则沿着这条记录的回滚指针去看上一个undo log，然后重复上面的判断



### 12.innoDB RR级别是否解决了幻读

部分解决了，没有完全解决

解决的情况：当前读、中间没有当前读的快照读

- 在当前读情况下，直接<font color="red">对读取的记录加<u>临键锁（记录本身和记录之间的间隙都会上锁）</u>，防止其他事务在这些行的间隙之间插入数据，</font><font color="orange">这里也要注意几个临键锁会退化为记录锁或间隙锁的情况，如等值查询给唯一索引加锁时退化为记录锁，向右遍历且最后一个不满足等值条件时退化为间隙锁</font>直到事务提交，连插入都不行，也就不会有幻读了
- 中间没有当前读的快照读：两次select用同一个read view，保证读取的都是第一次select前已提交的最新数据，那都是一样的

未解决的情况：中间存在当前读的快照读

![img](https://img-blog.csdnimg.cn/2020080117384283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTkwMDkx,size_16,color_FFFFFF,t_70)

例如上面这张图里的，虽然事务1的前两次select之前事务2进行了insert，但第二次select都没有出现幻读，因为这两个快照读用的是同一个read view，但第三次select出现了幻读，因为第二次和第三次select中间有一个update，这是一个<font color="Red">当前读</font>，读取了当前已提交的最新数据，所以<font color="red">第三个select会重新生成read view</font>，导致读取到了事务2新插入的id=3的这一行

### 13.mysql的七种join

![image-20230905210220429](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230905210220429.png)

![image-20230903222508157](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230903222508157.png)

![image-20230903223143314](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230903223143314.png)

- **内连接/等值连接inner join**

   select xxx form A <font color="red">[inner] join</font> B <font color="red">on</font> A.key=B.key

  ![image-20230903223637871](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230903223637871.png)

- **左外连接 left join**

   select xxx form A <font color="red">left [outer] join</font> B <font color="red">on</font> A.key=B.key

  ![image-20230903223816904](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230903223816904.png)

- **左外连接但不包括重合部分**

  select xxx form A <font color="red">left [outer] join</font> B <font color="red">on</font> A.key=B.key <font color="red">where B.key is null</font>

  ![image-20230903224032894](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230903224032894.png)

- **右外连接 right join**

  select xxx from A <font color="red">right [outer] join</font> B <font color="red">on</font> A.key=B.key

  ![image-20230903224157999](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230903224157999.png)

- **右外连接但不包括重合部分**

  select xxx form A <font color="red">right [outer] join</font> B <font color="red">on</font> A.key=B.key <font color="red">where A.key is null</font>

  ![image-20230903224438919](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230903224438919.png)

- **全连接 full join**

  select xxx form A <font color="red">full [outer] join</font> B <font color="red">on</font> A.key=B.key（mysql不支持full join这种写法，改为下面的）

  select xxx form A <font color="red">left [outer] join</font> B <font color="red">on</font> A.key=B.key <font color="red">**union(合并且去重)**</font> select xxx from A <font color="red">right [outer] join</font> B <font color="red">on</font> A.key=B.key

  ![image-20230903225310002](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230903225310002.png)

- **全连接但不包括重合部分**

​		select xxx form A <font color="red">left [outer] join</font> B <font color="red">on</font> A.key=B.key <font color="red">where B.key is null</font> **<font color="red">union(合并且去重)</font>** select xxx form A <font color="red">right [outer] join</font> B <font color="red">on</font> A.key=B.key <font color="red">where A.key is null</font>

​		![image-20230903230047266](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230903230047266.png)



### 14.redo log

redo log作用：保证持久性，当事务提交后所做的更改不会丢失

mysql底层的结构：

![image-20230907225858058](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230907225858058.png)

如上图所示，innoDB以<font color="red">“页”</font>的方式和硬盘交互，每一页存了若干条记录，原来数据页都存在硬盘里，但因为磁盘IO的速度很慢，所以真正操作数据页都是在内存的<font color="red">BufferPool</font>中，当要更新一条数据时，先看BufferPool中是否有这条记录所在的数据页，如果没有的话到磁盘读取到BufferPool中，<font color="Red">在更新之前将旧数据记录到undo log中</font>，然后<font color="Red">在BufferPool中对这个缓存页进行更新</font>，之后不会立马更新磁盘里的数据，而是<font color="red">后续在一定时机页合并时再刷盘</font>，BufferPool中和磁盘对应数据页不一致的缓存页称为<font color="red">“脏页”</font>。

所以，这就有一个安全风险：如果在BufferPool还没刷盘之前mysql宕机了，那么内存里的BufferPool就都没了，刚才还没来得及刷盘的新数据就不见了，所以需要用磁盘里的redo log保证持久性。

在对缓存页做更新的同时，会<font color="red">把“哪个数据页的哪个位置更新为了什么数据”记录到内存的redo log buffer</font>里，后续redo log buffer里的内容会进行刷盘，存到磁盘的<font color="red">redo log</font>中，刷盘的时机有事务提交、后台线程自动刷盘、缓存占用达一半等，有关redo log buffer在事务提交时的刷盘策略可以通过`innodb_flush_log_at_trx_commit`参数的值设置：

- 0：事务提交时不刷盘，而是交由后台线程进行，<font color="Red">每隔1s</font>将redo log buffer中的内容写到<font color="red">文件系统缓存page cache</font>，然后调用`fsync()`刷盘——<font color="orange">性能最高但不安全，可能会丢失最近1s的新数据，如果在这间隔的1s之内事务提交了，但突然宕机，还未来得及将redo log buffer移入page cache，或者还未来得及调用fsync刷盘，那么刚才提交的最新redo log就会丢失</font>

- 1(默认)：每次事务提交都会把redo log buffer的内容写到page cache，然后调用`fsync()`刷盘——<font color="orange">性能最低但最安全，只要事务提交成功，同时也会刷盘成功</font>

- 2：每次事务提交都会把redo log buffer的内容写到page cache，但由后台线程每隔1s调用`fsync()`刷盘——<font color="orange">性能和安全性介于上面二者之间，因为事务提交成功了那page cache里肯定有了，宕机前是否调用了fsync，如果还未调用的话确实还会有数据丢失</font>

  【综上，要保证数据持久性，`innodb_flush_log_at_trx_commit`参数的值一定要保持为默认的1】

注意：实际上不管设为多少，后台的线程都会<font color="Red">每隔1s</font>将redo log buffer中的内容写到<font color="red">文件系统缓存page cache</font>，然后调用`fsync()`刷盘，也就是设为1或2的情况只是增加了一个事务提交时的操作而已，另外当缓存占用达一半时也会进行刷盘。



redo log大小较小，且是<font color="red">顺序存储</font>，所以刷盘较为频繁，刷盘时机有事务提交、后台线程自动刷盘、缓存占用达一半等，其中有关事务提交时的刷盘策略设置如上所提；BufferPool中每个缓存页都较大，且是<font color="Red">随机存储</font>，所以刷盘不频繁，一般是等页合并的时候才刷盘



redo log的存储形式——环形数组的日志文件组，一组配置为若干个文件，从头开始写，写到末尾时会回到开始位置并覆盖旧的日志

![](https://oss.javaguide.cn/github/javaguide/10.png)

### 15.bin log

<font color="orange">redo log是innoDB独有的，bin log是所有mysq服务器都有的**逻辑日志（其他两种是物理日志）**</font>

bin log作用：数据备份、主从集群数据同步

bin log记录的是<font color="red">每一条SQL更新语句（不包括查询）的操作</font>，当进行数据备份、数据恢复、主从同步的时候就是通过bin log记录的历史操作进行，比如主从同步的时候从服务器读取主服务器的bin log，然后执行相同的操作；在mysql宕机时，通常会结合redo log和bin log一起做恢复，bin log记录的是需要做哪些操作，redo log记录的是对应的数据页要变成什么样。

写入机制：

对应redo log的redo log buffer，bin log也有bin log cache，也要通过page cache进行刷盘，也可以通过参数`sync_binlog`控制刷盘时机：

- 0：每次提交事务都只将bin log cache的内容写到page cache，由系统自行判断什么时候执行`fsync`。
- 1（默认）：每次提交事务时都写到page cache，然后`fsync`。
- N(N>1)：每次提交事务只将bin log cache的内容写到page cache，累计到N个事务的big log后执行`fsync`

存储格式：

- statement：记录SQL语句原文+事务ID，可能会有的问题：SQL语句执行的操作可能和时间有关，例如`update_time=now()`获取当前系统时间，会使得使用该语句进行复制的时候执行结果和原数据库的结果不一致
- row：相比于statement类型，将一些信息转化为了具体值，例如`update_time=now()`变成了具体的时间`update_time=1627112756247`，这种格式需要用mysqlbinlog工具解析才能看到具体内容
- mixed：判断这条`SQL`语句是否可能引起数据不一致，如果是，就用row格式，否则就用statement格式。

### 16.两阶段提交

因为redo log在事务没提交的时候也能刷盘（有默认的后台线程），但bin log只能在事务提交时刷盘，因此可能存在redo log刷了但bin log还未刷的情况，导致两个日志记录的内容不一致

解决：两阶段提交。将redo log的写入拆成prepare和commit两个步骤，写入redo log的时候为prepare，在写入binlog之后将redo log对应的字段改为commit。MySQL根据redo log恢复数据时，发现redo log还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务。



### 17.mysql分页查找

用<font color="Red">limit x,y</font>语句即可，<font color="Red">表示从第x条记录开始，一共显示y条记录</font>

每页显示多少条数据是自己设定的，若要求每页显示n条记录，则第i页（i从1开始）的limit范围为<font color="Red">limit (i-1)*n, n</font>

```mysql
#第一页数据,每页显示3条
select * from tablename limit 0,3;

#第二页数据,每页显示3条
select * from tablename limit 3,3;

```

### 18.mybatis的#{}和${}有什么区别

#{}：表示一个占位符，将传入的数据都当成一个字符串，并且会对传入的数据加双引号，能够很大程度防止sql注入(安全)

${}：直接就将传入的数据显示在sql语句中，不加双引号，无法防止Sql注入。 

（ Sql注入指的是程序解析时会将传入的参数作为原来SQL语句的一部分，而不是作为一个字段值，这样可能会打乱原来SQL的结构 ）

解释#{}和${}：

![](https://yangyujia.oss-cn-beijing.aliyuncs.com/meituan6%20%282%29.png)

![](https://yangyujia.oss-cn-beijing.aliyuncs.com/meituan7.png)

### 19.分库分表的优缺点

解决问题：一张mysql表的数据量过大，造成的存储压力大

**分库**

- 垂直分库：按照业务拆分，将原来在同一个数据库里的不同表放到不同的数据库中，如用户表放到用户数据库，订单表放到订单数据库。
- 水平分库（结合水平分表）：同一张表拆到不同的数据库中，例如，订单表的数据量过大，有1w条数据，可以把前5k条拆成表1，放到数据库1，后5k条拆除表2，放到数据库2

**分表**

- 垂直分表：把一个表按照列拆成多个表
- 水平分表：将一个表的不同行拆成不同表，一般会结合水平分库分到不同的数据库中

优点：解决了单库或单表存储数据量过大的问题，同时接受的请求可以分散打到不同的表或数据库，起到负载均衡的作用

缺点：http://career.cmbchina.com

1.本来一张表就能完成的查询内容可能需要查询多张表

2.可能会出现跨库join问题

3.横向扩容问题

4.结果集合并、排序问题

### 20.mysql innoDB按主键顺序插入还是无序插入的速度快

顺序插入的速度快，因为聚簇索引的结构是有序的，innoDB会把每条插入的记录存储在上一条记录的后面，当页达到一定阈值时下一条记录写入新的页中，这样可以减少磁盘的IO（因为每次新插入记录的时候都需要把那一个数据页读取到内存中，如果顺序插入的话大多数情况下不需要开辟新的页，也不需要读取新的数据页）

如果是无序插入的话，无法简单的把新来的数据放到索引的最后，这样会使得磁盘IO的数量很多（每一次要新增数据的那个数据页可能都不一样），另外可能需要做频繁的页分裂操作以便为新的行分配空间，页分裂会导致大量的数据移动，频繁分页也可能会使得页面变得稀疏

### 21.mysql优化规范

1. 没有特殊要求（如列存储等）情况下用innoDB引擎
2. 统一字符编码，均用UTF8，防止因为不同字符集进行比较前进行编码转换导致索引失效
3. 尽量控制单表数据量大小，可以用分库分表等手段控制数据量大小
4. 经常使用的列放到一个表中，避免更多的表关联操作
5. 不要存图片等大的二进制数据，存其地址即可
6. 避免使用TEXT、BLOB等大数据类型，因为当查询这类数据时，在排序等操作时，不嫩使用内存临时表，必须使用磁盘临时表，性能很差；另外给这种类型的字段加索引时只能使用前缀索引（因为索引字段长度有限制）
7. 某些字符串可以转换成数字类型存储（如IP地址）
8. 小数值类型，优先使用TINYINT类型
9. 尽量把所有列定义为NOT NULL，因为索引NULL列需要额外空间保存，且进行比较和计算时要对NULL值做特别处理
10. float和double会丢失精度，在避免丢失数字精度的场景使用<font color="red">decimal(p,d)</font>，表示存储一个最多p个数字，小数位数为d位的数字，例如decimal(6,2)存储范围为-9999.99~9999.99

#### 索引设计规范

1. <u>单表索引不超5个</u>：<font color="red">索引不是越多越好</font>，因为在查询时mysql优化器会根据每一个索引的情况生成最好的执行计划，如果同时考虑的索引很多，那就会<font color="red">增加mysql查询优化器生成执行计划的时间</font>；另外<font color="red">索引会降低表的增删改速度</font>，因为每次增删改都要动态修改索引结构。
2. <u>不要用全文索引</u>：不适用于OLTP场景
3. <u>尽量使用联合索引而非给表中每一列都建立单独的索引</u>：虽然5.6后有了合并索引的优化方式，但还是远远没有使用一个联合索引的查询方式好
4. 使用innoDB引擎时，<u>每个表必须有主键</u>，注意：不要用频繁更新的列作为主键、不要用多列主键（相当于联合索引）、不要用UUID/MD5/HASH字符串作为主键（无法保证数据的顺序增长）、主键建议使用自增ID
5. 对于<u>频繁查询字段优先考虑建立<font color="red">覆盖索引（包含了所有查询字段的索引）</font>，来避免回表</u>
6. <u>避免建立重复的索引</u>，例如有了联合索引(a,b,c)就不要建立(a)、(a,b)了，会增加查询优化器生成执行计划的时间
7. <b>建议设置为索引的列</b>：
   - where/order by/group by/distinct子句中使用的字段
   - 多表join的关联列（尽量不要使用外键foreign key，会影响父表和子表的写操作而降低性能）
8. **联合索引中列的顺序：**
   - <font color="red">区分度最高（能检索出最少数据）的字段放在联合索引最左侧</font>
   - <font color="red">字段长度越小的列放在越左侧</font>（字段长度越小，一页能存的数据量越大，磁盘IO次数越少）
   - <font color="red">使用越频繁的字段放在越左边</font>（因为能较少地建立索引，比如建立联合索引(a,b,c)时也建立了(a)、(a,b)这两个索引）

#### sql语句开发建议

1. <font color="red">尽量不在sql语句里做复杂运算</font>，而是在业务逻辑中完成，避免数据库的负担过重
2. where子句中不要进行<font color="red">计算、函数、类型转换</font>等操作，避免索引失效
3. <font color="red">尽量不要用select *而改用select <字段列表></font>，一方面避免查询出无用字段，另一方面select *不会用到覆盖索引
4. <font color="red">避免数据类型的隐式转换</font>，防止索引失效
5. 避免使用子查询，<font color="Red">把子查询优化为join</font>，原因：子查询的结果集存在内存临时表或者磁盘临时表中，因为不存在索引所以无法使用索引
6. 在明显不会有重复值时使用UNION ALL而不是UNION，这样可以少一个去重操作
7. 禁止用order by rand()随机排序，因为对每一行都会生成一个随机数，浪费大量资源
8. 将大的sql语句拆分为多个小sql，因为大的sql逻辑复杂，需要占用大量cpu资源进行计算，且一条sql只能用一个cpu来完成，sql拆分后可以通过并行执行来提高效率

### 22.delete、drop、truncate

![image-20231021091303531](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231021091303531.png)

delete：

- 属于<font color="red">DML（数据库操纵语言），写在事务中需要手动commit，可以回滚</font>

- 用来删除表中数据

- 用法

  ```mysql
  #删除表中全部数据
  delete from 表名;
  #按条件删除表中的一些行
  delete from 表名 where 条件
  ```

- 只删除表中数据，保留表结构、索引、触发器

truncate：

- 属于<font color="red">DDL（数据库定义语言）,不需要手动commit，自动提交，不可回滚</font>

- 用来删除表中所有数据

- 用法

  ```mysql
  #删除表中所有数据
  truncate table 表名;
  ```

- 只删除表中数据，保留表结构、索引、触发器

drop：

- 属于<font color="red">DDL（数据库定义语言）,不需要手动commit，自动提交，不可回滚，</font>

- 用来删除整个表（结构+数据）、数据库

- 用法

  ```mysql
  #删除表
  drop table 表名;
  #删除数据库
  drop database 数据库名;
  ```

- 当删除表的时候，所有与之相关联的索引、完整性约束和触发器也被删除。



上面三者的效率：drop>truncate>delete

### 23.int(11)的意思

int的占用字节数（32位）是一定的，和括号里的数字没有关系，各种类型占用的字节数如下表所示：

![image-20231026210618503](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231026210618503.png)

int(11)括号里的这个表示“显示宽度”，**在对应的字段设置为unsigned zerofill（无符号且填充0）时才有意义，**作用是<font color="red">当对应的字段值长度不足11时，在前面补0，例如插入"12345678"，会补成"00012345678"，</font>当导出数据时候会将前面的0显示出来，长度≥11的值不受影响

### 24.in关键字有什么要注意的吗

- in关键字可能会导致不走索引，而是转为全表扫描
- 对于in后面跟的离散值，没有个数要求

### 25.explain关键字

执行explain +sql语句时，会显示一张表，包含了mysql优化器的执行计划信息，表中每一行表示执行计划中的一步操作。

这些表的字段从左到右分别为：

1. **id：每个操作的执行顺序。**相同的id是从上到下执行，不相同的id是大的先执行，id为null表示最后出来的结果集。

2. **select_type：每步操作的查询类型。**

   其中的几种（不全）：

   - SIMPLE：简单select，不包括子查询或union
   - PRIMARY：整个语句包含子查询时最外层的查询
   - SUBQUERY：在select或where中包含的子查询
   - DERIVED：在from中包含的子查询
   - UNION：union关键字的后一个查询
   - UNION RESULT：union查询的结果

3. **table：这个操作查询的数据表。**

   **`<unionM,N>`** : 本行引用了 id 为 M 和 N 的行的 UNION 结果；

   **`<derivedN>`** : 本行引用了 id 为 N 的表所产生的的派生表结果。派生表有可能产生自 FROM 语句中的子查询。

   **`<subqueryN>`** : 本行引用了 id 为 N 的表所产生的的物化子查询结果。

4. **partitions：表分区，也就是前面的table可以通过指定列进行分区。**

5. **type：在表中找到所需行的方式，是否用了索引**

   从差到好依次为：

   - ALL：全表遍历
   - index：遍历某个索引树（常见于where字句未使用索引但是select的字段加了索引）<font color="red">如果使用了覆盖索引，则会显示为index</font>
   - range：查找某个索引树的一个范围（常见于where子句用了索引，但是不是等值查询，而是≥、between等）
   - ref：使用非唯一索引的等值查询，或者表关联中使用非唯一索引相等作为关联条件
   - eq_ref：使用唯一索引的等值查询，或者表关联中使用唯一索引相等作为关联条件
   - const：查询优化器把where子句优化为一个常量
   - system：const的特例，查询优化器把where子句优化为一个常量，且对应表只有一行

6. possible_keys：可能使用的索引，但不一定被使用

7. key_len：索引中使用的字节数

8. ref：表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

9. rows：估计的返回的结果集数目，不一定准确

10. filtered：按表条件过滤后，六年的记录数的百分比

11. extra：其他信息，如是否使用文件内排序、使用使用了临时表保存中间结果、是否用了覆盖索引所以不用回表、是否用了distict等

### 26.mysql语句的执行过程

#### mysql的结构

- server层
  - 连接器：用户身份认证、权限验证
  - 查询缓存（mysql8.0后移除）：连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询语句，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。
  - 分析器：分析SQL语句，包括两步：1. 词法分析（提取关键字，如select，查询的表名、字段名、查询条件等） 2.语法分析（验证语法是否正确）
  - 优化器：制定执行的最优方案，如使用多个索引时如何选择索引，多表查询时如何选择关联顺序等
  - 执行器：执行方案，执行之前还会再做一步权限验证，通过了就会调用存储引擎接口，返回执行结果
- 存储引擎

#### 执行顺序

1. 首先，连接器检查用户的身份和权限，通过了才能执行后面的步骤
2. mysql8.0之前，查询缓存里是否有以这条SQL语句为key的结果，有的话直接返回，否则下一步
3. 分析器进行词法分析，提取关键字、表名、字段名等），然后进行语法分析，看语法是否正确
4. 优化器确定执行方案，如使用多个索引时如何选择索引，多表查询时如何选择关联顺序等
5. 执行器执行方案，在执行之前还会再做一次权限验证，然后返回结果

## 数据结构

### 一、快排的过程及时间复杂度分析

过程：

```java
void QuickSort(int a[],int l,int r)
{
    if(l>=r){
        return;
    }
    int pivot=a[l];//选取表中第一个元素作为枢纽值
    int i=l,j=r;
    while(i<j)
    {
        while(i<j&&pivot<=a[j])j--;
        a[i]=a[j];
        while(i<j&&pivot>=a[i])i++;
        a[j]=a[i];
    }
    a[i]=pivot;
    QuickSort(a,l,i-1);
    QuickSort(a,i+1,r);
}
```

<font color="red">最差**n^2**，最好nlogn，平均nlogn，取决于所选择的基准值</font>

最坏情况：<font color="red">总是以第一个元素（实际上最小的那个）作为基准值，且要处理的数组有序，</font>这个时候递归调用的两个子数组中左边那个总是为空，这时候一共要递归n次（两个子数组算一层，一层一个递归）

平均情况：<font color="red">总是将中间元素（实际应该排在中间的那个）作为基准值，</font>这时候只用递归logn次

每一次递归都要遍历n个元素（每一层虽然被分在很多个函数中排序，但是加起来都是那么多个元素）

所以最坏情况n^2，最好情况nlogn，平均也是nlogn，因为平均就是取到中间那个位置

### 二、用一个数据结构实现LRU（最近最少使用算法）

LRU缓存：删除的是最久未使用的数据

一个数组存元素，一个数组存对应下标元素的最近一次使用时间

#### 基于hashmap+双向链表实现LRU

双向链表的每个Node有四个属性：

- key：每个节点进入的时候都是以<font color="blue">(key,value)</font>的形式进入的，Node的key和value对应的就是这两个
- value：
- prev：前一个Node
- next：后一个Node

每次使用数据，或者插入新数据的时候，我们把它移动到头部（可分为删除该节点及在双向链表头部添加节点这两步操作），这样尾部节点就是下一次要替换的那个节点。

hashmap用于快速查找，hashmap的key为节点的key，value为对应Node。

##### get操作

首先利用hashmap判断key是否存在，不存在就返回-1，存在则 key 对应的节点是最近被使用的节点，通过哈希表定位到该节点，并将其移动到双向链表的头部，最后返回该节点的值。

##### put <key,value>操作

利用hashmap判断key是否存在，如果存在则覆盖对应节点的value，并将该节点移到头部，不存在则执行以下操作：

创建一个新Node，添加进hashmap，然后将该Node添加进双向链表的头部，如果此时链表长度超出容量，则删除最尾部的节点。

【这个双向链表可以用java自带的集合LinkedList，每个元素存key即可】

```java
public class LRUCache {
    class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
        public DLinkedNode() {}
        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}
    }

    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();
    private int size;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode newNode = new DLinkedNode(key, value);
            // 添加进哈希表
            cache.put(key, newNode);
            // 添加至双向链表的头部
            addToHead(newNode);
            ++size;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode tail = removeTail();
                // 删除哈希表中对应的项
                cache.remove(tail.key);
                --size;
            }
        }
        else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node.value = value;
            moveToHead(node);
        }
    }

    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    private void removeNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }

    private DLinkedNode removeTail() {
        DLinkedNode res = tail.prev;
        removeNode(res);
        return res;
    }
}
```

### 3.解决hash冲突的方法

- 拉链法（链地址法）：将所有hash值相同的元素记录到同一个链表中

  好处：简单

- 开放地址法：发生冲突时寻找一个新的空闲位置
  - 线性探测：当某个key发生了哈希冲突，那不断将这个key+1然后再重新取模算hash值，例如原来key=4，4%6=2发生了冲突，那就算(4+1)%6、(4+2)%6……
  - 平方探测（二次探测）：和线性探测的区别是，线性探测每次将key+1,也就是key+1、key+2、key+3、key+4……是向同一个方向找空闲；平方探测法是左右跳跃着找：key+1^2、key-1^2、key+2^2、key-2^2、key+3^2、key-3^2……
  - 伪随机数：每次寻找下一个位置时，key增加的值是随机的，用一个伪随机数生成器生成
  
- 再哈希法：同时构造多个不同的哈希函数，一个函数发生冲突了就用下一个哈希函数再算过

- 建立公共溢出区：将哈希表分为基本表和溢出表，将发生冲突的元素放在溢出表中

### 4.常用的加密算法

#### 对称加密算法

加密和解密用同一密钥

**DES**

对于要加密的明文，<font color="red">每64位一组进行加密</font>，不足64位的要进行填充



**AES**

#### 非对称加密算法

分为公钥私钥，公钥加密的内容只能由私钥解密，私钥加密的内容只能由公钥解密。所有想和服务器进行通信的客户端持有同一个公钥，服务器保留私钥，这些客户端用公钥对数据进行加密，服务器用私钥进行解密

**RSA**

#### 散列加密算法

**MD5**

**SHA系列算法**

### 5.排序算法

![image-20231003122132974](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231003122132974.png)

注意：上面的in-place和out-place指是否需要申请额外空间，不是内部排序或外部排序的意思，这些都是内部排序，<font color="red">外部排序是针对大文件排序时需要访问外存的那种排序</font>。

比较类排序及非比较类排序：

- 比较类排序：冒泡排序、快速排序、插入排序、希尔排序、选择排序、堆排序
- 非比较类排序：基数排序、计数排序、桶排序

#### 冒泡排序

**最好O(n)，其他O(n^2)，稳**

一个嵌套循环，外面<font color="red">for(int i=1;i<n;i++)</font>，里面<font color="red">for(int j=0;j<n-i;j++)</font>，逐个比较a[j]和a[j+1]，如果a[j]>a[j+1]的话则交换顺序。<font color="red">每一轮都是把本轮遍历到的最大的那个数移到了最后面</font>。

最好O(n)——需要优化：<u>在外层循环加一个判断是否有序的boolean值</u>，如果这轮遍历发现已经是有序了的，那就不需要下一轮遍历了，直接break

#### 插入排序

**最好O(n)，其他O(n^2)，稳**

从第一个数开始，认为它已经排好序，对于未排序的数据，从已排序部分<font color="red">**从后向前**</font>进行扫描，<font color="red">找到合适的位置将未排序的数据插进去</font>。【**稳定：**因为是整体后移而非交换】

最好O(n)：刚好就是有序的情况下，只用顺序遍历每个数即可

优化——<font color="red">二分插入</font>排序：在寻找每一个数的插入位置时，不要用之前从后向前的顺序遍历，而是用二分查找法找到插入的位置

#### 选择排序

**都是O(n^2)，不稳**

首先在<font color="red">未排序序列</font>中找到最小（大）元素，存放到<font color="red">排序序列的起始位置</font>，然后，再从<font color="red">剩余未排序元素</font>中继续寻找最小（大）元素，放到<font color="red">已排序序列的末尾</font>。以此类推，直到所有元素均排序完毕。【**不稳定**：在把后面的数据放到前面时，实际上两个数据进行了<font color="dark green">**交换**（注意不是整体后移！！比如说现在数组是1,2,3,5,6,4，前三个数字已经排好序了，未排序部分最小的数是4，那么就是将4和5交换变成1,2,3,4,6,5，而不是说直接把4插到前面变成1,2,3,4,5,6）</font>，所以当a1=a2时且原本a1在前面时，a1可能因为和a2后面的某个数字发生交换而跑到了a2后面，所以最后的结果a1可能会在a2后面】

#### 希尔排序（分组插入排序）

**最好O(nlogn)，最坏O(n^2)，平均O(nlogn)**

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，<font color="red">设置若干个gap，每相隔一个gap的元素在同一组，组内自己插入排序</font>，一开始gap=length/2，后面每一轮gap都缩为前一轮的一半。等gap为1时，其实就是传统的全组插入排序，但这时已经排过很多轮了，微调一下就可以了。【**不稳定：**因为gap的原因相同元素可能被分到不同组】

#### 归并排序

**时间复杂度都是O(nlogn)，空间复杂度O(n)，稳**

递归，分治

每次递归将这个数组分为两个数组，分别对这两个数组进行排序，最后合并两个数组的排序结果【**空间复杂度是O(n)：**虽然每次递归调用都需要申请一定长度的额外空间用于合并，但这个申请的额外空间递归结束后就释放了，且在任意时刻CPU只有一个函数在执行，这个申请的额外合并空间最大的是n】

#### 快速排序

**最好和平均O(nlogn)，最坏O(n^2)，不稳**

也是分治法、递归——递归函数的参数是左边界l、右边界r，当l>=r时直接return，否则令i=l，j=r

- 具体的代码和选取的基准值位置有关

- 常规的是选择第一个元素为基准值：令pivot=nums[i]，while(i\<j)时j、i交替走，j先走，当i < j且nums[j]≥pivot时j--，j停下来的时候令nums[i]=nums[j]，然后到i走，当i < j且nums[i]≤pivot时i++，i停下来的时候令nums[j]=nums[i]，最后ij相遇，<font color="red">nums[i]=pivot，然后把[l,i-1]和[i+1,r]两半部分也进行递归。注意：当基准值就取第一个数的时候【**不稳定:**因为j--的条件是>=而不是>，i++的条件是<=而不是<】

  ```java
  void QuickSort(int a[],int l,int r)
  {
      if(l>=r){
          return;
      }
      int pivot=a[l];//选取表中第一个元素作为枢纽值
      int i=l,j=r;
      while(i<j)
      {
          while(i<j&&pivot<=a[j])j--;
          a[i]=a[j];
          while(i<j&&pivot>=a[i])i++;
          a[j]=a[i];
      }
      a[i]=pivot;
      QuickSort(a,l,i-1);
      QuickSort(a,i+1,r);
  }
  ```

- 选择最后一个元素为基准值：代码和上面的基本一样，只是变为i先走

  ```java
  void QuickSort(int a[],int l,int r)
  {
      if(l>=r){
          return;
      }
      int pivot=a[r];//选取表中最后一个元素作为枢纽值
      int i=l,j=r;
      while(i<j)
      {
      	while(i<j&&pivot>=a[i])i++;
          a[j]=a[i];
          while(i<j&&pivot<=a[j])j--;
          a[i]=a[j];
      }
      a[i]=pivot;
      QuickSort(a,l,i-1);
      QuickSort(a,i+1,r);
  }
  ```


#### 堆排序

**都是O(nlogn)，不稳**

注意是内部排序，因为所有元素都是在原地进行排序的

![image-20231003145917447](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231003145917447.png)

【**时间复杂度O(nlogn)：** 初始化堆的时间复杂度O(n)，n-1次交换第一个元素到最后一个位置、再调整为堆的时间复杂度是O(nlogn)，所以总时间复杂度是O(nlogn)。**空间复杂度O(1)**：因为所有元素是就地构建为大顶堆/小顶堆的，**不稳定：**因为调整堆的过程中可能会改变相同元素的相对顺序】

可以用java的集合类优先队列<font color="red">PriorityQueue（默认小顶堆）</font>来实现：

```java
public static int[] heapSortByPriorityQueue(int[] nums){
        PriorityQueue<Integer> priorityQueue=new PriorityQueue<>();
        for(int n:nums){
            priorityQueue.offer(n);
        }
        for(int i=0;i<nums.length;i++){
            nums[i]=priorityQueue.poll();
        }
        return nums;
    }
```

如果是大顶堆的话可以重写Comparator接口中的compare：

```java
PriorityQueue<Integer> bigHeap=new PriorityQueue<>(new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o2-o1;//小于0的话o1排前面，大于0的话O2排前面
    }
});
```

如果要升序排序用大顶堆（因为堆排序的过程是把根元素和最后一个元素进行交换，用大顶堆的话刚好是把大的元素移到后面），要降序排序用小顶堆（就是反过来）

如果不用PriorityQueue，自己实现堆排序的话，代码见《学习项目》

#### 计数排序

**令k=数组中最大数-数组中最小数+1，时间复杂度都是O(n+k)，空间复杂度为O(k)，稳**

1. 求出数组的最大值max和最小值min，额外申请一个长度为max+1-min的数组C，然后遍历原数组，遍历到数字x时，C[x-min]++
2. 遍历数组C，从下标i=1开始C[i]=C[i]+C[i-1]
3. 从后往前遍历原数组，遍历到每个元素x时，C[x-min]-1的值就是这个元素排序后的下标，然后C[x-min]--

#### 桶排序

1. 设置一个size，作为每个桶能放多少个不同数的值，这些桶之间本来就是有序的
2. 遍历原数组，<font color="red">设置一定映射函数</font>，把数据依次映射到对应的桶里
3. 对每个非空的桶内的所有数字进行排序，<font color="red">可以使用其他排序方法，也可以递归使用桶排序</font>
4. 按顺序把每个桶进行拼接

#### 基数排序

桶按数组中数字的个位数、十位数……划分的特殊的桶排序

先根据个位数将每个数字分到不同的桶里，每个桶内部不需要再排序，按原来数字的先后顺序放即可，然后合并多个桶；下一轮按十位数分桶；再下一轮按百位数字……

如下图：

![image-20231003212050022](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231003212050022.png)

## 计网

### 1、浏览器输入一个url到返回内容的过程

![image-20230809001958907](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230809001958907.png)

1.DNS解析（浏览器缓存->操作系统缓存->DNS缓存->本地域名服务器->根域名服务器->顶级域名服务器->二级域名服务器，得到最后的IP后本地域名服务器将之存在DNS缓存里，）

2.客户端浏览器与服务器建立TCP连接

3.建立http连接，向服务器发送http请求

4.服务器处理请求

5.服务器返回HTML结果

6.浏览器将进行页面渲染，显示结果

### 2、http和https，https的原理

http的安全性问题：

- 使用明文通信，内容可能会被窃听
- 不验证通信方的身份，可能会遭遇伪装
- 无法证明报文的完整性，报文可能被篡改

**https——http+SSL/TLS**

SSL：安全套接字协议，TLS是SSL的升级版

- 对称加密：通信双方使用同一密钥进行加密和解密。缺点：如果密钥一暴露那就失去保护功能了。
- 非对称加密：所有想和A通信的发送方发出的消息都是用A提供的同一公钥进行加密的，A收到这些消息后用自己的私钥进行解密。缺点：会有**中间人攻击**——C和A正式通信之前要先获得A的公钥，如果这时候来一个攻击者B，给C发送一个诈包，骗它说这是A的公钥（实际上是B自己的公钥），那么C给A发的消息就会用B的公钥进行加密，B捕获这些消息就可以用自己的私钥解密。
- 证书加密（数字签名技术）：由一个受信任的第三方证书颁发机构CA给各服务器颁发证书，CA知道服务器的公钥，<font color="orange">对公钥进行hash运算后得到一个hash值，然后对这个hash值进行RSA加密运算得到一个数字签名</font>。服务器把这个证书发给客户端，客户端知道CA的公钥，<font color="orange">对签名进行RSA解密运算得到hash值，再对公钥进行hash运算也得到hash值，比较这两个hash是否相同，相同则验证通过</font>，该公钥没有经过篡改。

**Https总体过程——两次http请求：**

第一次：

1.客户端想服务器发起HTTPS的请求，连接到服务器的443端口；

2.服务器将<font color="red">包含非对称加密的公钥的证书</font>回传到客户端

3.服务器<font color="red">通过证书验证公钥</font>，如果有问题，则HTTPS请求无法继续；如果没有问题，则上述证书中的公钥是合格的。客户端这个时候随机生成一个用于对正式通信数据进行<font color="red">对称加密的密钥(client key)</font>以及<font color="red">对称加密的算法</font>，使用非对称加密的公钥对client key进行非对称加密；

第二次：

4.进行二次HTTP请求，将加密之后的client key传递给服务器；

5.服务器<font color="Red">使用非对称私钥进行解密，得到client key,使用client key及对称加密的算法对数据进行对称加密</font>【后续就是通过对称加密来进行通信了，后面的对称加密密钥不再传输，而是服务器和客户端各自保留，不会被截获】

6.将对称加密的数据传递给客户端，客户端使用对称解密，得到服务器发送的数据，完成第二次HTTP请求

**也就是正式通信数据用对称加密，该对称加密的密钥用非对称加密，该非对称加密的公钥用证书加密（数字签名）**

#### 完整的SSL/TLS握手过程（TLS1.2版本）

1. client发送请求给server，连同<u>TLS版本、可用加密套件（也就是支持的加密算法）、<font color="red">第1随机数</font></u>一起发送
2. server收到后选择一个加密算法，并生成第2随机数，将<u>选好的加密套件、<font color="red">第2随机数</font></u>发送给client
3. server将<u><font color="red">包含非对称加密公钥的数字证书</font></u>发给client
4. client收到后，用数字证书验证非对称加密公钥的合法性，通过后<u>生成<font color="red">第3随机数（预主密钥）</font>，用收到的非对称加密公钥加密后</u>发送给server
5. server收到后，用非对称加密私钥解密得到这个第3随机数
6. client和server<font color="red">都用第1随机数、第2随机数、第3随机数，结合之前选择的加密套件，计算出相同的会话密钥（对称加密密钥）</font>
7. 后面双方的通信就是通过这个对称加密密钥进行通信

### 3.TCP的可靠传输保证

#### TCP流量控制（只在乎端到端的传输控制）

发送方维持一个<font color="red">可变长滑动发送窗口，</font>大小取决于接收方的接收窗口，发送方要收到接收方返回的确认号了滑动窗口才能向前移动

#### TCP拥塞控制（涉及网络性能等，是全局的）

发送方增加一个<font color="red">拥塞窗口(cwnd)</font>，拥塞窗口大小取决于网络拥塞情况，并会动态变化，<font color="red">发送方将发送窗口取为拥塞窗口和接收方接收窗口中较小的一个</font>

TCP传输层几种拥塞控制算法：

- 慢启动：发送方开始发送数据后，先探测一下网络状况，然后从小到大两倍两倍地增大拥塞窗口（一开始拥塞窗口为1，一个报文来回之后变为2，下一个来回再变为4、8、16……）
- 拥塞避免：<u>当拥塞窗口大小大于一个设定的阈值ssthresh之后</u>，改为每经过一个来回拥塞窗口就+1，而不是变成两倍
- 快速重传：目的是快速恢复丢失的数据包。如果接收方收到一个不按顺序的数据段，就立即给发送方发送一个重复确认，如果发送方<font color="red">收到3个重复确认都指明了同一个数据段，那么会认为这个数据段丢失了，立即重传，</font>也就是<font color="red">第3次</font>收到确认号均为x的报文时就会重传序号x开头的数据包。（之前没有快重传机制时，如果数据段丢失了，会使用定时器来要求传输暂停，在暂停这段时间不能发送新的数据段，就浪费了很多时间）
- 快速恢复：在快速重传之后，TCP发送方会进入快速恢复状态，此时将拥塞窗口大小设置为拥塞窗口阈值ssthresh的一半，并开始拥塞避免

### 4.TCP报文结构

![](https://pic4.zhimg.com/80/v2-f9eb4f1737ea1ec6c79ca1571a3c9dfb_720w.webp)

TCP报文中没有长度信息，而TCP是面向字节流的，如何区分一个完整的TCP报文呢？

一般三种方法：固定长度（几乎不用）、特殊分隔符（如http用的TCP以回车符为一个分隔符）、自定义消息格式（比如在数据携带的消息里增加一个标明长度的字段）

### 5.TCP三次握手四次挥手

![](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png)

**一次握手**:客户端发送带有 SYN（SEQ=x） 标志的数据包 -> 服务端，然后客户端进入 **SYN_SEND** 状态，等待服务器的确认；

**二次握手**:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端,然后服务端进入 **SYN_RECV** 状态

**三次握手**:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，然后客户端和服务器端都进入**ESTABLISHED** 状态，完成 TCP 三次握手

![](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-waves-four-times.png)

**第一次挥手**：客户端发送一个 FIN（SEQ=x） 标志的数据包->服务端，用来关闭客户端到服务器的数据传送。然后客户端进入 **FIN-WAIT-1** 状态。

**第二次挥手**：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包->客户端 。然后服务端进入 **CLOSE-WAIT** 状态，客户端进入 **FIN-WAIT-2** 状态。

**第三次挥手**：服务端发送一个 FIN (SEQ=y)标志的数据包->客户端，请求关闭连接，然后服务端进入 **LAST-ACK** 状态。

**第四次挥手**：客户端发送 ACK (ACK=y+1)标志的数据包->服务端，然后客户端进入**TIME-WAIT**状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 **2MSL** 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。

### 6.OSI七层模型和TCP/IP四层模型

#### OSI七层模型

1. 物理层：透明地传送比特流
2. 数据链路层：以数据帧的形式传送数据，并进行误差纠正控制
3. 网络层：提供路由和寻址、局域网划分的功能
4. 传输层：为两台主机进程之间的通信提供通用的数据传输服务
5. 会话层：管理应用程序之间的会话
6. 表示层：进行数据处理（解编码、加密解密、压缩解压缩等），并展示内容
7. 应用层：直接为用户提供服务

(1、2对应TCP/IP<font color="Red">网络接口层</font>，3对应TCP/IP<font color="red">网络层</font>，4对应TCP/IP<font color="red">传输层</font>，5、6、7对应TCP/IP<font color="red">应用层</font>)

### 7.什么协议用TCP，什么协议用UDP

TCP强调可靠传输，面向连接，有流量控制、差错恢复，适合传送大量数据以及对传输可靠性要求较高的场景：Http、Telnet（远程登录）、FTP（文件传输协议）、SMTP（用来发送邮件）、POP3（用来接收邮件）

UDP速度快，无连接，不提供可靠性、流量控制、差错恢复机制，适合对速度要求高但可靠性要求低、传送少量数据的场景：DHCP（动态主机配置协议，用于动态配置IP地址）、DNS协议（域名解析系统）、SNMP（简单网络管理协议，用来管理网络设备）

### 8.ping的工作原理

ping的原理是通过发送<font color="red">ICMP报文</font>给对方，并且要求对方回复同样大小的应答报文，从而测量往返时间(RTT)以及检测目标主机是否可达。

1. ping可以ping ip或ping 域名，如果ping的是域名，要先把域名转为ip（涉及缓存、DNS域名解析）
2. 将要ping的ip和自己的子网掩码进行与运算，计算出相应的网段
3. 看这个网段是否和自己是同一个网段，如果是的话通过路由协议找到到达这个网段的下一跳路由器地址
4. 看本机ARP缓存表里是否有下一跳路由器地址的mac地址
5. 

### 9.路由协议都有哪些

按静态、动态及动态路由依据划分

- 静态路由
- 动态路由
  - RIP：由跳数距离来决定下一跳走哪个
  - OSPF：由带宽、时延决定下一跳走哪个

按照路由协议作用区域划分：

- 内部网关协议IGP（在单一的自治系统中交换路由信息）
  - RIP、OSPF
- 外部网关协议EGP（在不同的自治系统中交换路由信息，例如一个系统用RIP，另一个用OSPF）
  - BGP

### 10.http消息结构

#### 请求消息

![](https://img-blog.csdnimg.cn/551a5ed5c87e496cbfddcc2455235057.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l6ICB6ZOB5bmy5LqG6L-Z56KX5Luj56CB,size_18,color_FFFFFF,t_70,g_se,x_16)

![](https://img-blog.csdn.net/20140610210038140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YW5kcm9pZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- 请求行
  - 请求方法：get、post、delete、put等
  - URL：要调用的接口链接
  - 协议版本

- 请求头部：由若干个键值对组成，每行一对，关键字和值用:分割，关键字包括下面几种：
  - User-Agent：产生请求的浏览器类型
  - Accept：客户端可识别的内容类型列表
  - Host：请求的服务器的域名
  - content-type：内容类型
  - ……

- 请求数据：get方法中不用这一部分，post方法中包含要传递的表单数据

#### 响应消息

![](https://img-blog.csdnimg.cn/d38230fbf8554f80bbb32c5e8e1663d6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l6ICB6ZOB5bmy5LqG6L-Z56KX5Luj56CB,size_12,color_FFFFFF,t_70,g_se,x_16)





## 操作系统

### 1.如何理解硬盘、内存、寄存器，并说说他们在java中是怎么用的

<font color="red">cpu访问快慢的速度依次为：寄存器-> 缓存->内存->硬盘</font>

- **寄存器：**寄存器是<font color="red">中央处理器的组成部分</font>，是一种<font color="red">直接整合到cpu中的有限的高速访问速度的存储器，</font>它是由一些<font color="red">与非门</font>组合组成的，分为通用寄存器和特殊寄存器。cpu访问寄存器的速度是最快的。那为什么我们不把数据都存储到寄存器中呢，因为寄存器是一种容量有限的存储器，并且非常小。因此只把一些<font color="red">计算机的指令等一些计算机频繁用到的数据存储在其中</font>，来提高计算机的运行速度。
- **缓存**：<font color="red">内存中高速缓存（cache）</font>,它之所以存在，是因为当cpu要频繁访问内存中的一些数据时，如果每次都从内存中去读，花费的时间会更多，因此在寄存器和内存之间有了缓存，把cpu要频繁访问的一些数据存储在缓冲中，这样效率就会更高。缓存又可以分为<font color="red">一级</font>和<font color="Red">二级</font>缓存，一级的速度大于二级的速度。因此cpu在访问数据时，先到缓存中看有没有，没有的话再到内存中读取。
- **内存：**分为<font color="red">只读（ROM，存固化数据，只有部分能够擦除，且要用光擦除或电擦除）</font>和<font color="red">随机存储器（RAM，断电即失忆）</font>。其中RAM应用非常广泛，例如在平常用的开发板中的内存指的就是RAM，还有我们电脑上的内存条指的就是RAM。

- **硬盘、U盘等存储器**都归入外存储器，它们的访问速度是最慢的。

 **java中怎么用**

栈和堆位于内存（RAM）中，堆栈中一些常用数据放在缓存中（栈放在一级缓存，堆放在二级缓存），在执行一些计算的时候会用到寄存器，在读取文件、保存文件的时候会用到硬盘，例如通过BufferedReader从标准输入中读取字符串。

### 2.操作系统从用户态切换到内核态的几种情况

### 3.栈的增长方向，是参数先入栈还是返回地址先入栈

栈的增长方向一般是<font color="red">从高地址往低地址增长</font>（和堆相反），<font color="red">参数先入栈</font>

## redis

### 1.为什么要用redis，redis的优缺点

#### 用redis的意义：

- 高性能。对于常用数据，直接存到内存的缓存里就不用每次都从磁盘里拿，和传统数据库不同，redis是<font color="red">内存数据库</font>，数据存在内存中，且redis存储的是键值对数据，读写速度非常快，被广泛应用于缓存。
- 高并发。直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。

【还有一种著名的分布式缓存脚Memcached，两者都是基于内存的，性能都很高，但redis支持更丰富的数据类型，有灾难恢复机制，且原生支持集群模式……】

#### redis的优缺点：

- 优点：

  1. **支持多种数据类型**：支持set（集合）、zset（有序集合）、list、hash、string这基本类型，还支持基数统计、位存储、地理位置这三种特殊数据结构。 <font color="grey">如果在做好友系统，查看自己的好友关系，如果采用其他的key-value系统，则必须把对应的好友拼接成字符串，然后在提取好友时，再把value进行解析，而redis则相对简单，直接支持list的存储(采用双向链表或者压缩链表的存储方式)。 </font>
  2. **持久化存储**：内存数据库最担心的是万一机器宕机数据就丢失，redis使用<font color="red">**RDB快照文件**（RDB是redis在内存中所存储的全部数据的二进制表示，可以通过加载该文件恢复数据，rdb快照可以存在硬盘或复制多份传到远端服务器）</font>或<font color="red">**AOF**（ 通过保存Redis服务器所执行的写命令来记录数据库状态，存在硬盘里，想要恢复的时候重新执行一遍这些操作）</font>做数据持久化。
  3. **性能很好**： 全内存操作，所以读写性能很好。

- 缺点；

  1. 由于是内存数据库，所以单台机器存储的数据量跟机器本身的内存大小有关。虽然redis本身有key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。 

     <font color="grey">删除数据的策略：惰性删除（ 只会在取出 key 的时候才对数据进行过期检查 ）、定期删除（ 每隔一段时间抽取一批 key 执行删除过期 key 操作 ）</font>

  2. 通过生成rdb文件进行同步备份，会消耗一定的CPU资源

  3. 修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，redis不能提供服务。 

  4. 不支持回滚，redis事务不满足原子性，也不满足持久性。

### 2.缓存击穿、缓存穿透、缓存雪崩及其应对策略

#### 缓存击穿

当大量请求某一个key（**热点数据**），但该key<font color="red">存在于数据库中但不存在于缓存中（可能是因为过期了）</font>，导致大量瞬时请求直接打在数据库上。

解决方法：

- 设置热点数据<font color="red">永不过期或者过期时间比较长</font>。

- 针对热点数据<font color="red">提前预热</font>，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。

- 请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。

#### 缓存穿透

大量请求的key是不合理的，<font color="red">根本不存在于缓存中也不存在于数据库中</font>，(例如黑客伪造的假key）导致请求直接到了数据库，没有经过缓存这一层，对数据库造成了巨大压力。

解决方法：

- <font color="red">缓存无效key</font>：如果缓存和数据库中都查不到某个key那么就将这个key存到另一个redis缓存中并设置一个较短的过期时间。缺点：会导致这个专门用来存失效key的缓存中存着大量的无效key

- <font color="red">布隆过滤器</font>：在缓存之前加一个布隆过滤器，把所有有效的key存在该布隆过滤器中，有请求过来时通过过滤器判断是否是有效key，如果无效的话直接返回错误。缺点：布隆过滤器<font color="red">**可能会将没有的元素判为有，但反过来不会**</font>

  （原因是布隆过滤器由一个位数组+若干个hash函数组成，当加入一个key时会通过这些hash函数计算出若干个hash值然后将位数组的对应位置为1，当判断一个key在不在布隆过滤器中时也会进行同样的hash计算，然后根据位数组对应的位是否全为1来判断那个key在不在里面，这时候不同的key可能会计算出同样的hash值，所以会存在误判；

  另外<font color="orange">布隆过滤器只能加入元素而不能删除元素</font>，原因是如果删除元素了，之前对应的位就要重新置为0，会影响到还在里面的元素的判断）

#### 缓存雪崩

缓存<font color="red">在同一时间大面积的失效</font>，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力

<font color="red">缓存服务宕机</font>也会导致缓存雪崩

解决办法：

- 针对缓存服务宕机的情况：
  - 采用redis<font color="red">集群</font>，避免因为单机出现问题导致整个缓存服务不可用
  - <font color="red">限流</font>，避免同时处理大量请求
- 针对热点缓存失效的情况：
  - 设置不同的失效时间比如<font color="red">随机设置缓存的失效时间</font>。
  - 缓存永不失效（不太推荐，实用性太差）。
  - 设置二级缓存。如可以用caffeine在redis前面加一个二级缓存，先到这个二级缓存中拿数据，拿不到再到原来的缓存，再拿不到的话再去磁盘拿，这样多了一层缓冲

### 3.缓存更新和数据库更新策略

业内通用手段：删掉缓存，更新数据库

## 问项目/实习

### 1.宜搭中用了哪些设计模式，结合业务讲讲

### 2.授权模型（RBAC权限管理）

RBAC：基于角色的访问控制，<font color="red">将**权限**赋予某些**角色**，然后将**若干个角色**赋予**用户**，从而使得用户拥有了对应的权限</font>

![image-20240226102441829](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240226102441829.png)

注意点：

- 互斥角色的处理：当用户当前角色和要添加的新角色互斥时，应该在添加新角色时提示角色互斥，必须要撤销前一个角色再添加新角色。
- 三大著名安全原则
  - 最小权限原则：将角色的权限配置成其完成任务所需的最小权限集合
  - 责任分离原则：当要处理一个高敏感任务时，可以要求两个互斥的角色共同完成
  - 数据抽象原则：可以将操作抽象为权限，例如财务操作用借款、存款等抽象权限，而不是使用典型的读、写、执行权限

- 在宜搭的场景里，把多对多的用户-角色授权表改成了多用户-一角色的授权表，如平台访问者授权表、应用访问者授权表，平台访问者授权表有<font color="red">”授权企业“字段，需要用户以这个企业的身份登录验权才能通过</font>；应用访问者授权表有<font color="red">“授权企业”、”授权应用“字段，需要用户以该企业的身份登录，且访问的是该应用验权才能通过</font>。

实习举例：

例如宜搭里有“平台访问者”、“应用访问者”、“表单访问者"、“表单数据查看者”等角色，平台访问者的权限是使用宜搭，应用访问者的权限是使用某个应用，表单访问者的权限是通过某张表单提交数据，表单数据查看者的权限是查看某张表单的提交记录。在给下级用户分发宜搭账号进行授权时，其实就是给某个下级用户授予”平台访问者“的角色，使那个用户可以访问宜搭平台。

假设A是上级企业，B是下级企业（钉钉中有个逻辑，下级企业用户会被自动加入上级企业中，也就是若zhangsan只在B这家公司，但是他实际上是可以以A和B公司的身份登录钉钉的），A的管理员给B的一个用户zhangsan赋予了”平台访问者“角色，此时用户-角色授权表里就会多一条记录，表明zhangsan被赋予了平台访问者角色，授权企业是A。在一般的场景中，当zhangsan访问宜搭时，会校验zhangsan是否有**当前登录企业身份**的平台访问者角色，如果有的话就验权通过，也就是说，zhangsan必须以上级企业A的身份登录才行。

在一种特殊的场景，即上级企业A的某成员创建了一个应用，并且设置只有下级企业B的成员才有”应用访问者“的角色，这时候把该应用发给B企业的员工zhangsan使用。zhangsan点击这个应用时，**系统首先会校验其是否有”平台访问者“角色，校验通过后再校验它是否有这个应用的”应用访问者“角色。**当zhangsan以A企业身份登录时，”平台访问者“校验通过，但”应用访问者”校验不通过；以B企业身份登录时，”应用访问者”校验通过，但”平台访问者“校验不通过，也就是zhangsan根本无法使用该应用。

优化：在这种特殊场景（应用所属企业和访问者当前登录企业不一致）校验平台访问者角色时，首先<u>按照通常方法看用户是否有他所登录的企业的平台访问者授权</u>，有的话直接验证通过；没有的话首先判断用户当前登录的企业和应用所属企业<u>是否构成上下级关系，如果构成的话，校验该用户是否有该应用所属企业的平台访问者授权</u>，有的话也通过，zhangsan之前有A的平台访问者授权，所以验权通过。

### 3.数据迁移

需要注意以下三点：

1. 异构数据库表之间的映射处理
2. 停机时间的容忍，以及迁移过程中若线上数据发生了变化，要怎么处理
3. 若发生意外，要怎么处理

迁移步骤：

1. 对源数据库进行备份
2. 编写自动化迁移脚本，脚本里注意处理表中业务含义相同但字段名称不同的列，这里也可以选用一些自动迁移工具
3. 在实习的组里，实际迁移之前会做一些引导（也就是我所做的工作的那一部分，将用户从旧版引导至新版宜搭），所以在迁移过程中，原数据表的增量会比较少
4. 在迁移时，因为整个表的数据量比较大，所以要分多次迁移，每次迁移其中的一小部分
5. 迁移结束后，使用日志验证原数据表是否有增量，或者有旧数据被更改，如果有的话单独进行处理。

## linux系统

### 1.查看服务器资源消耗情况/查找java程序cpu占用最高的线程

https://juejin.cn/post/7327190463232327720

- `top`命令可以看进程占用资源情况，按`shift+p`可以按照CPU消耗降序排序
- `top -H -p [pid]`  可以看某进程的线程占用情况
-  `ps -mp pid -o THREAD,tid,time | sort -rn` 获取线程信息，并找到占用CPU高的线程
-  `jstack [进程id] |grep -A 10 [线程id的16进制]` 查看线程的堆栈信息（线程id的16进制可以通过`printf “%x\n” [线程id]`  打印出来）

### 2. 发送文件的命令

- scp：使用SSH安全地在本地和远程之间复制文件

  ```shell
  scp 发送方在远程机器上的用户名@目标主机:目标文件夹
  ```

- ftp：传统的文件传输协议，但并不安全因为数据未加密

  ```shell
  ftp 目标主机
  put 本地文件名 远程文件名
  ```

- SFTP：安全的文件传输协议，和FTP相似但是通过SSH加密

  ```
  sftp 发送方在远程机器上的用户名@目标主机
  put 本地文件名 远程文件名
  ```

- wget：用来下载文件

  ```shell
  wget http://....
  ```

  

### 3. 查看服务器负载和资源占用情况，以及性能监控

#### 查看磁盘或文件大小

- df：查看<font color="red">整个文件系统</font>的磁盘空间使用情况，包括整个文件系统分区的总空间、已使用空间、剩余空间、挂载点等，<font color="red">注意针对整个文件系统，而不是针对单个文件或目录</font>

  `加选项 -h：以人类可读形式（如MB、GB）来显示分区信息`

- du：用于查看<font color="red">指定目录下所有文件的大小，或者直接查看某文件的大小</font>

  如果后面跟的是一个目录，会一个个文件大小单独显示

  `加选项-h：以人类可读（MB、GB）形式显示`

  `加选项-s：不单独一个个文件形式 显示，以汇总求和的形式显示`

  ![image-20240226215547005](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240226215547005.png)

  ![image-20240226215753656](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240226215753656.png)

#### 查看内存大小

- free：显示当前（非实时，实时的用top）系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存

  `加选项-h：以人类可读（MB、GB）形式显示`

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210514142944122.png)

#### 查看负载

- top：**实时**的监控， 包括进程、CPU负载、内存使用等等

  `top -H -p [pid]`  可以看某进程的线程占用情况

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210415155339881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ2NTM5NQ==,size_16,color_FFFFFF,t_70)

- iostat：显示磁盘IO开销（非实时，但可以设置参数让其隔几秒更新一次）

  `iostat -x 1 10    :-x表示显示所有参数信息，1表示每隔1秒监控一次，10表示共监控10次`

![image-20240226220433079](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240226220433079.png)

- netstat：查看网络连接、路由表、接口统计等网络信息，有助于发现网络拥塞（非实时）

### 4.孤儿进程和僵尸进程

正常情况下，父进程通过fork()创建子进程，子进程再创建它的子进程，父子进程是异步的，父进程永远无法预测子进程的结束，所以当子进程调用exit()结束后，它的PCB（进程描述符）还存在系统中（这样做的原因是父进程需要通过PCB获得子进程的状态信息，包括是否已结束），待父进程会调用wait()或waitpid()后才会被回收。

- 僵尸进程：<font color="red">子进程退出了，但是父进程没有用wait或waitpid，那么子进程的进程描述符PCB仍然保存在系统中</font>，这种进程称为僵尸进程。ps命令查看时状态是“Z”，且该进程无法用kill杀死。【危害：占用大量进程号，可能导致没有足够的进程号分配给接下来的新进程】
- 孤儿进程：<font color="red">父进程结束了，而它的一个或多个子进程还在运行，那么这些子进程就成为孤儿进程</font>，子进程的资源由init进程(进程号PID = 1)回收。【危害：无，因为最后也会被init进程回收】

解决方案：

孤儿进程最后会被init进程回收，不用解决，解决僵尸进程的方法是把它的父进程kill掉，使之变成孤儿进程，再由init进程回收。

### 5.进程、线程、协程

- 进程：资源分配的最小单位
- 线程：进程内CPU分配的最小单位
- 协程：<font color="red">用户态的轻量级线程</font>，不由OS内核管理，完全由程序代码控制，因此协程调度不需要进入内核态，相比线程，上下文切换开销很小，可以在一个线程中创建多个协程。协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作用户空间栈，完全没有内核切换的开销。

## 设计模式

### 工厂模式（类创建型）

原理：定义一个工厂类Factory，以及要创建的物品的接口，还有所有物品类型的实现类，当要创建具体某个类的实例对象时，统一使用工厂类进行创建，通过传递一个参数的形式表明要创建的是哪一个类的对象

好处：不用为每个具体类都弄一个工厂，而是通过同一个工厂类进行对象的创建。

![](https://www.runoob.com/wp-content/uploads/2014/08/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg)

工厂类代码：

```java
public class ShapeFactory {
    
   //根据传入的参数决定实例化哪个类的对象，也可以将该方法弄成static静态方法，这样不用创建工厂类的实例就能调用了
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
}
```

客户端代码：

```java
public class FactoryPatternDemo {
 
   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();
      //创建Circle对象，并调用它的 draw 方法
      Shape shape1 = shapeFactory.getShape("CIRCLE");
      shape1.draw();
      //创建Rectangle对象，并调用它的 draw 方法
      Shape shape2 = shapeFactory.getShape("RECTANGLE");
      shape2.draw();
      //创建Square对象，并调用它的 draw 方法
      Shape shape3 = shapeFactory.getShape("SQUARE");
      //调用 Square 的 draw 方法
      shape3.draw();
   }
}
```

### 抽象工厂模式（对象创建型）

原理：工厂模式通常只有一类产品族，所以一个工厂就可以了，抽象工厂模式通常有多类产品族，每个产品族都有一个对应的工厂，然后有一个大的抽象工厂来创建所有产品族的工厂，从而创建所有产品族下面的产品。

适用情况：当需要创建一个产品族时

![image-20230409164759793](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230409164759793.png)

如上，海尔具体工厂和TCL具体工厂都继承于EFactory这个抽象工厂类，这两个具体工厂可以生产对应产品族的产品，例如海尔具体工厂可以生产海尔电视和海尔空调，TCL抽象工厂可以生产TCL电视和TCL空调，客户端代码如下：

```java
//创建海尔具体工厂并通过该工厂创建海尔空调和电视：
EFactory haierFactory=new HaierFactory();
Television haierTelevision=haierFactory.produceTelevision();
AirConditioner haierAirConditioner=haierFactory.produceAirConditioner();
//创建TCL具体工厂并通过该工厂创建海尔空调和电视：
EFactory tclFactory=new TCLFactory();
Television tclTelevision=tclFactory.produceTelevision();
AirConditioner tclAirConditioner=tclFactory.produceAirConditioner();
```

### 单例模式（对象创建型）

原理：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

适用情况：当需要某个类在全局只有一个实例时

<font color="red">一般来说单例类中的方法都弄成static静态方法，这样不需要实例化对象</font>

![](https://www.runoob.com/wp-content/uploads/2014/08/62576915-36E0-4B67-B078-704699CA980A.jpg)

单例类SingleObject代码（饿汉式）：

```java
public class SingleObject {
 
   //创建 SingleObject 的一个对象
   private static SingleObject instance = new SingleObject();
 
   //让构造函数为 private，这样该类就不会被实例化
   private SingleObject(){}
 
   //获取唯一可用的对象
   public static SingleObject getInstance(){
      return instance;
   }
 
   public void showMessage(){
      System.out.println("Hello World!");
   }
}
```

客户端代码：

```java
public class SingletonPatternDemo {
   public static void main(String[] args) {
 	//获取唯一可用的对象
      SingleObject object = SingleObject.getInstance();
      //显示消息
      object.showMessage();
   }
}
```

### 模板方法模式（类行为型）

原理：<font color="red">其实就是最基本的继承结构</font>。定义一个抽象父类和一个具体子类，抽象父类中定义一个<font color="red">模板方法</font>，这个模板方法有若干个<font color="red">步骤</font>，这些步骤已确定实现的可写成具体方法，未确定的可写成抽象方法，交给子类实现，也可以是钩子方法（两种钩子方法——第一种是父类定义的是空方法或某个默认的实现，看子类是否覆盖，若覆盖就按子类的执行，否则按父类默认的执行；第二种是在某个方法执行之前先调用一下钩子方法看是否返回true，返回true再执行下面的，否则不执行，父类中可以默认返回true或false，子类也可以覆盖）

![image-20230409212637010](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230409212637010.png)

### 策略模式（对象行为型）

原理：做一件事可能有多种策略，在一些条件下选择某一种，例如去学校有打车、步行、坐地铁，当天晴时步行，当下雨时打车，当下雪时坐地铁，那么原本需要用大量if else语句来根据条件选择方式，现在可以向context传递一个参数表明用哪种策略，然后context创建这个具体的策略类，再调用这个具体策略类的方法

![](https://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg)

### 观察者模式（对象行为型）

原理：定义对象间的一种一对多依赖关系，每当被观察目标的状态（属性或数据）发生改变时，通知所有观察者。

![image-20230409171838118](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230409171838118.png)

注意：

- 被观察者抽象类持有观察者接口，因为要通过notify通知所有观察者
- 观察者具体类持有被观察者具体类，因为要通过getState知道该被观察者现在的状态

### 适配器模式（类结构型/对象结构型）

原理：定义一个适配器类(Adapter)，这个适配器类可以提供所有客户端所需要的接口，当客户端调用适配器类的方法时，适配器类可以调用合适的适配者类(Adaptee)的方法，而这个过程对客户端透明。

适用情况：通过适配器，可以调用适配者里很多用户原本不能调用的接口

分为对象适配器、类适配器两种

- 对象适配器：可以适配很多个adaptee

![image-20230409203839792](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230409203839792.png)

对象适配器代码：

```java
public class Adapter extends Target{
    private Adaptee adaptee;
    public Adapter(Adaptee adaptee){
        this.adaptee=adaptee;
    }
    public void request(){
        adaptee.specificRequest();
    }
}
```

- 类适配器：Adapter类继承Adaptee类，同时在Adapter中可以改变specificRequest()的具体代码，做更大的变化

![image-20230409204808102](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230409204808102.png)

类适配器代码：

```java
public class Adapter extends Adaptee implements Target{
    public void request(){
        specificRequest();
    }
}
```

### 装饰模式（对象结构型）

原理：可以不更改原有类，就能够动态地给原有类的对象添加一些额外的属性和行为，方法是创建一个装饰类来包装原有类，该装饰类继承于原有类，但添加了新的属性或行为

适用情况：不想改变原有类但想为其添加新的属性或行为时

![image-20230409210639145](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230409210639145.png)

### 代理模式（对象结构型）

原理：引入一个代理对象来实现对真实对象的操作，或者将代理对象作为真实对象的替身使用。代理类和真实对象类都继承于同一个类，因此有部分相同的方法，代理类中的方法可以比真实对象类多一些或少一些，但新增的方法客户端是不能调用的

适用情况：当无法访问真实对象时（例如真实对象在远程主机上）

![image-20230409211459042](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230409211459042.png)

代理模式和适配器模式看起来有点像，里面最关键的是代理模式的代理和真实类是继承了同一个父类，但适配器模式的适配器和适配者继承的不是同一个父类

## 分布式

### CAP原则是什么

C：一致性（集群中所有数据副本在同一时刻具有同样的值）

A：可用性（只要收到用户请求，集群就必须给出回应并返回结果）

P：分区容忍性（集群必须要容忍这种情况发生：因为网络故障或机器故障，使得某些机器之间无法通信）<font color="red">在分布式系统中，P一定要保证，因为无法保证100%不发生故障</font>

**CAP原则：三个要素最多只能同时满足两点**

**当一定要保证P时，C和A不能共存**，原因：一旦发生了网络故障或机器故障，说明集群中至少有两部分之间不能相互通信，假设这两部分是part1和part2，如果要保证一致性，那么这两部分都不能响应用户请求，因为若其中一个部分的机器响应了用户请求，那么它必须把用户的修改信息同步给另一个部分的机器，但是此时这两个部分不能通信了，因此若要保证一致性，此刻肯定是不可用的，反过来，要保证可用性，也就是这两个部分至少还有一个部分能响应用户请求，那么肯定就无法保证一致性。

选择CP还是AP要看业务场景，如果是银行等需要强一致性的业务会选择CP

### BASE理论

BA：basically available（基本可用：在发生故障时，允许损失部分可用性，如响应时间变慢、某些功能不可用，但不是系统完全不可用）

S：soft-state（软状态：允许系统不同节点之间进行数据同步时存在延时）

E：eventually consistent（最终一致性：在经过一段时间的数据同步后，系统中所有节点最终能达到一致）

BASE是对CAP中C和A权衡的结果：即使无法做到<font color="red">强一致性</font>，但每个应用都可以根据自身业务特点，采用适当的方式达到<font color="red">最终一致性</font>

### 三种一致性

从强到弱分别：

- **强一致性**：任何时刻系统写入了什么，读出来的就是什么。
- **弱一致性**：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。
- **最终一致性**：保证在某个规定的时间内达到数据一致的状态

业界推崇的是最终一致性，但某些业务如银行业务要求强一致性

**实现最终一致性的方法：**

- 读时修复：在读取数据时，检测数据的不一致，如果发现不同节点的副本数据不一致，则修复
- 写时修复（性能消耗最低）：在写入数据时，如果节点之间传递数据失败，则把数据缓存下来，然后定时重传
- 异步修复：定时检查节点副本的不一致并修复

## 场景题

### 1.秒杀系统相关设计问题

秒杀系统（如商品秒杀、抢票、抢课等）的三大特性：高并发、高性能、高可用

#### 超卖（乐观锁）

- 方法一（不推荐）：在可能产生超卖的方法语句块中使用Synchronized等悲观锁机制

```java
/**
* 售卖商品的接口
**/
@PostMapping("/pessimisticLockSold")
public R pessimisticLockSold(Integer userId, Integer goodsId) {
    log.info("用户Id = {},商品Id = {}", userId, goodsId);
    try {
        //使用悲观锁防止超卖，这里是对整个CommodityOrderController对象都加锁了
       synchronized (this) {
       			int orderId = commodityOrderService.overSold(userId, goodsId);
       			return R.success().data("orderId", orderId);
            }
        } catch (RuntimeException e) {
            e.printStackTrace();
            return R.failed().message(e.getMessage());
        }
    }
```

缺点：效率低，难以达到每秒并发量的要求

- 方法二（推荐）：乐观锁解决超卖

在商品库存表里增加一个“version（版本号）”字段，某个线程先读取对应库存表的库存，且<font color="red">连同版本号一起读出来</font>，判断是否当前库存>0，如果是则进行库存-1的操作，<font color="red">同时把version也+1，该update操作的where子句必须包含version=#{version}</font>，这样如果在读取库存→更新库存的过程中这个商品对应的库存被别的线程改了，那么verison就不一样了，这个时候这个线程就不能update了（判断update的行数为0，返回“抢购失败，请重试”）。

相应的数据库语句为：

```mysql
update Commodity 
set remain=remain-1,version=version+1  
where id = #{id} and version = #{version}
```



#### 高并发（接口限流）

秒杀系统会在一瞬间发送上亿次请求，为了做限流和负载均衡处理，通常一个秒杀系统都是一个单独的服务（单一职责）

##### 接口限流算法

- **固定窗口计数器法（不佳，无法保证限流速率，且有临界问题）**

思想：规定每个<font color="red">固定的单位时间窗口分片</font>只能处理n个请求，超过n个就拒绝

缺点：无法保证限流速率，并且有临界问题，比如若规定每分钟处理请求不超200个，某恶意用户在0:0:59发送100个，在0:1:01发送200个，它是满足算法的（0:1:00是两个时间窗口的分界点），但实际上这个系统3秒内就收到了300个请求，会崩溃。

- **滑动窗口计数器法（能一定程度上保证限流速率，解决了临界问题）**

思想：时间窗口可以以一定速率向前移动，规定该时间窗口内最大请求数目，例如一个1分钟的时间窗口，每秒向前移动一格，保证每1分钟的最大请求数目都不会超过规定值，那么就会解决临界问题。

- **漏桶（可以保证限流速率，但不能灵活应对突发大量请求）**

思想：把流入的请求看作注水到桶里，处理请求的过程看作漏桶漏水，<font color="red">请求以任意速率流入，以固定速率流出，超出桶容量的请求则丢弃</font>。

实现：用一个队列保存请求，然后以一定的速率从队列中拿请求来执行，如果请求到来时刻队列满了那抛弃请求；或者(如果单单要看这个请求是否还能进入的话）初始化一个容量值和初始时间，并设定一个恒定速率，每次请求过来的时候都用现在时刻算一下留了多少水、还剩多少容量，容量为0的话这个请求就被抛弃。

缺点：不管桶里的请求有多少，处理请求的速率是恒定的，因此不能灵活应对突发极大量请求的情况

- **令牌桶（能应对突发极大量请求）**

思想：<font color="red">以固定速率在桶里生成很多令牌，如果桶满了就不能生成了，每个请求到来的时候要先取得令牌，如果取不到令牌则被丢弃</font>（注意并不一定是一个请求消耗一个令牌，大的数据包消耗的令牌会更多），最后取得了令牌的请求能够被处理，否则被丢弃

优点：相比漏桶算法，能更灵活地应对突发极大量请求的情况，因为只要那个请求取得了令牌那最后都会被处理

实现：谷歌guava的令牌桶RateLimiter（要先maven导入guava依赖）

```java
import com.google.common.util.concurrent.RateLimiter;

public class RateLimiterDemo {

    public static void main(String[] args) {
        // 1s 放 5 个令牌到桶里也就是 0.2s 放 1个令牌到桶里
        RateLimiter rateLimiter = RateLimiter.create(5);
        for (int i = 0; i < 10; i++) {
            double sleepingTime = rateLimiter.acquire(1);//获取1个令牌，返回等待时间
            或者：
            boolean acquire = rateLimiter.tryAcquire(1, 1, TimeUnit.SECONDS);//获取1个令牌，如果等待时间超过了1秒则拒绝
        }
    }
}

```

拓展：平滑预热令牌桶

平滑突发限流就是按照指定的速率放令牌到桶里，而平滑预热限流会有一段预热时间，<font color="red">预热时间之内，速率会逐渐提升到配置的速率</font>。

除了guava外别的令牌桶/漏桶三方库：Bucket4j、Resilience4j 

##### 单机限流和分布式限流方法

- **单机限流：**使用google guava的RateLimiter，结合令牌桶的平滑突发限流、平滑预热限流。

- **分布式限流：**
  - redis计数器：在请求过来的时候使计数器+1，并判断是否到达上限，如果到达上限则进行拦截。并开启一个定时任务使计数器减一个值
  - alibaba sentinel：直接下载对应jar包然后运行jar包，然后在项目.yml配置文件中加上sentinel端口，然后就可以进入sentinel的界面进行一些流量配置
  - 网关层限流：通常也需要借助一些中间件，如redis+lua

#### 恶意请求

指一个人可能一次性购买很多，然后倒卖（黄牛）

#### 高性能

可以使用一些负载均衡策略，例如网络上的负载均衡，以及数据库分库分表



### <span id="jump1">2.成千上万个文件的大工程如何检查出内存泄漏位置</span>

可以通过在发生OOM时生成<font color="red">**dump文件（某时刻的内存快照）**</font>分析，dump是jvm运行时内存的一份快照，利用它可以分析是否存在内存浪费，可以检查内存管理是否合理，当发生OOM的时候，可以找出问题的原因。

(1)生成dump文件有以下几种方法：

- 运行时手动输命令生成

  ```shell
  jmap -dump:file=javaDump.dump,format=b 25535
  //针对pid为25535的java进程，生成一个名为javaDump.dump的当前内存快照文件
  ```

- 设置程序发生OOM时自动生成

  设置jvm启动参数：

  ```shell
  -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./
  //设置在发生OOM时，将dump文件输出到./（根目录）下。
  ```

(2)分析dump文件的方法

- 使用jdk自带工具**<font color="red">jhat</font>**

  通过jhat xx.dump/hprpf命令能够分析xx.dump文件，然后本地访问http://localhost:7000，即可在浏览器看到访问效果。

  ![image-20230707211609315](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230707211609315.png)

- 使用jdk自带工具**<font color="red">jvisualvm</font>**

  找到$JAVA_HOME/bin/jvisualvm.exe，双击即可启动，启动后点击左上角文件->装入，装入想要分析的dump文件即可

  ![image-20230707211627727](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230707211627727.png)

  将dump文件导入jvisualvm之后，就可以看是哪个对象使用内存过多，从而定位问题	

  如下图，将dump文件导入jvisualvm，可以看到大量char[]占用了空间；逐步展开至实例，可以看到一些实例占用了大量的内存空间，从而定位内存泄露的位置

  ![](https://pic1.zhimg.com/v2-7fb192025feb9636da7dbe2d20e49df8_r.jpg)

  ![](https://pic1.zhimg.com/v2-d599363d68be6322ea3ee4fb80da1058_r.jpg)

​		如果要进一步分析的话，可以通过右下角的“引用”窗口一层层地展开，看这些占大量内存的实例被谁引用，然后这些对象又被谁引用……从而找到问题所在。

【补充：jvisualvm不仅可以导入dump文件，也可以直接生成dump，获得一份内存快照信息，点右上角“dump”按钮即可】

![](https://img-blog.csdnimg.cn/20200806201529641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMyMjMyNjgz,size_16,color_FFFFFF,t_70)

### 3.大文件如何排序

使用<font color="red">分治+外存保存中间结果+多路归并+败者树</font>的思路：

1. 分多次读取这个大文件，假设一共有1千万行，每次只读取其中的若干行，如1000行

2. 对这读取的1000行数据进行排序，然后用有效的内部排序算法（如快排）对这些数据进行排序，并<u>将排序结果写入到新的子文件里（或者覆盖原来的位置也可以）</u>，这样就有了10000个有序的小文件

3. 用<u>多路归并</u>的方法，合并这10000个有序小文件的结果为一个大的最终结果，申请一个和原文件一样大的空间，将每一次归并后的结果存入新的空间中，最后把新空间的内容覆盖原空间即可

   **多路归并的过程：（提高k路归并的k值，每一次io多拿一些数据，能够减少io次数，但会增加每轮归并时的比较次数）**

   传统的归并排序是二路归并，也就是两个数组一组合并为一个大的数组，k路归并就是k个小数组一组合并为一个大的数组，每一次比较都是比较现在这些数组里面最小的那一个数，找到这些最小值里的最小值，拿出来作为归并结果里的下一个数，然后再比较一次最小值……

   **引入败者树来减少每一次归并找最小值时的比较次数：**

   ![image-20231015231948522](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231015231948522.png)

   传统的k路归并中，每要找到下一个数都要经过k-1次比较，太多了，使用败者树，构造一棵完全二叉树，非叶子节点存的这两次比较中的败者（也就是值更大的那个数），然后下一次是胜者和兄弟胜者相比较，再存败者，然后胜者再参与下一轮比较……最后到根节点就是最后一次比较的败者，最上面伸出一个最高的节点表示最后胜出的那个数，下一轮就是把前一轮胜出的数弹出后，开始下一次这样的比较。

   因为是一个树形结构，所以每一轮只用比较logk次，除去建树的那部分，一共就比较**nlogk**次，n是总数据量大小，k是k路归并的k

   <font color="red">使用非叶子节点存胜者块下标的胜者树更直观，但是败者树重构时更为方便，所以选败者树更好</font>

   

### 4.大文件找到第k大的数

#### 堆排序法

【找topk问题有快排和堆排这两种方法，但是由于内存空间装不下这么多数据，所以堆排序是最合适的

​	<font color="red">找第k大的数则建立最小堆，找第k小的数则建立最大堆</font>

】

**找第k大数：**首先取文件的前k个元素建立一个<font color="red">最小堆，存目前遍历过的数中前k个最大的数</font>，后面就是维护这个大小为k的最小堆，<font color="red">在遍历到元素i时看i是否比堆顶大，是的话弹出堆顶元素，然后把i添加进去，重新整理堆内元素顺序</font>，堆里存的永远是目前遍历到的元素中最大的k个，堆顶元素是其中最小的那个，也就是目前遍历到的元素中topk大的那个。

**找第k小的数：**反过来，建立的是大小为k的<font color="red">最大堆，存目前遍历过的数中前k个最小的数</font>，遍历到i时<font color="red">看是否小于堆顶元素，是的话弹出堆顶元素，然后把i添加进去，重新整理堆内元素顺序</font>，最后遍历完所有数后堆顶元素就是topk小的数

**时间复杂度：nlogk，n为文件中的数字总数**

#### 归并排序法

将大文件分割成m块，每块大小n/m，顺序地对每个小块进行堆排序求出前k大/小的数字，每小块进行堆排序的时间复杂度**(n/m)logk**，一共m块则时间复杂度为**m(n/m)logk**

然后进行m路归并，找到这m个堆中前k大的数字，这里使用败者树，时间复杂度为**klogm**

综合时间复杂度为**m(n/m)logk+klogm**

### 5.高并发需要考虑的点

- 架构设计
  - 水平扩展：增加更多机器，垂直扩展：升级现有硬件
- 负载均衡
- 数据库优化
  - 读写分离
  - 索引
  - 分库分表
  - 缓存
- 应对并发请求
  - 异步处理机制（如消息队列）
  - 线程池、连接池
- 限流

### 6.数据迁移

实习经历中，内部集团版宜搭的迁移涉及了数据库的迁移，其中涉及到表结构不同的表之间的迁移，迁移步骤是这样的：

- 



## 综合性问题

### 1.三个优点和三个缺点

三个优点：

- 主动性强：出于想学习的心理，毕设中主动提出要做核心的交互模块，口红知识图谱系统项目也提出要做最难的智能问答模块
- 勤学好问：上课有不懂的问题下课都会问老师，每一位老师都记得我了
- 比较坚韧，遇到困难不退缩：大三的时候保研的经历

三个缺点：

- 考虑问题比较全面，所以有的时候会有点优柔寡断
- 说话比较直接，性格比较直
- 对一些小事有点较真，比如别人可能只是出于客套，跟我说了句周末要不一起吃个饭，然后我就当真了，周末了真的去问他

### 2.职业规划

一年内充分学习，对xx行业和咱们团队的技术架构进行充分的理解，对技术有追求，希望在职业过程中不断提升自己的技术，并且按质按量地完成各种需求。希望3年左右能够晋升一级，6-8年左右成为小组长。因为我之前也了解到咱们物流部是个新成立没多久的部门，现在淘天也很重视，所以我希望我能够通过自己的努力，使得我们团队发展的更好。

### 3.实习时候遇到的困难

1.业务上的困难：对之前完全没涉足过低代码领域，也没用过宜搭，对低代码开发一窍不通，对很多业务需求背景也不了解，产品写的prd也很抽象，看的我云里雾里。

解决方案：入职第一周花了一周时间学习宜搭的使用，业务需求有不懂的就找产品当面问清楚

2.开发流程上的困难：因为之前没有在互联网大厂实习过，不知道怎么起步开发一个新需求

解决方案：看新人文档，问师兄师姐

3.技术方面的困难：比如如何定位一个bug，以及一些中间件的学习

解决方案：看新人文档，问师兄师姐，还有因为阿里实习生看不到ATA，所以我都是缠着一位师姐帮我在ATA上查，搞得她都有点烦了

### 4.选择工作最看重的几个点

1.平台公司，因为我觉得大的平台对我的技术提升以及职业发展都更有好处，比如阿里这样的大平台

2.行业（前景、发展现状），国家政策（提升内需、发展交通）、以及公司的重视程度

3.base，很喜欢xx，有很多同学和朋友打算来xx发展
